---
title: "Programaci√≥n funcional en R"
author: Julen Astigarraga y Ver√≥nica Cruz-Alonso
date: today
date-format: "DD/MM/YYYY"
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
editor_options: 
  chunk_output_type: console
number-sections: true
---

## Presentaci√≥n

Los **objetivos** de este taller son:

-   aprender las bases de la programaci√≥n en R

-   aprender a escribir funciones

-   aplicar funciones en programaci√≥n iterativa mediante el paquete {purrr} de {tidyverse}

-   aprender estilos de c√≥digo que facilitan su comprensi√≥n (üìù)

Dentro del modelo de ciencia de datos de Hadley Wickham (@fig-datascience), el curso de centra en el marco que envuelve todo el proceso, es decir, la programaci√≥n.

![Modelo de ciencia de datos de Hadley Wickham. Traducido de https://r4ds.hadley.nz/intro#fig-ds-diagram](images/datascience.png){#fig-datascience}

### Estructura del curso

+------------------------------------------+---------------+
| Bloques                                  | D√≠a           |
+==========================================+===============+
| Presentaci√≥n del curso                   | 13/05/24      |
|                                          |               |
| Introducci√≥n a la programaci√≥n en R      |               |
|                                          |               |
| Introducci√≥n a la programaci√≥n funcional |               |
+------------------------------------------+---------------+
| Teor√≠a sobre funciones en R              | 15/05/24      |
|                                          |               |
| C√≥mo escribir funciones                  |               |
+------------------------------------------+---------------+
| Programaci√≥n orientada a objetos         | 20/05/24      |
|                                          |               |
| Programaci√≥n funcional                   |               |
|                                          |               |
| Iteraciones sobre uno y dos argumentos   |               |
+------------------------------------------+---------------+
| Iteraciones sobre m√∫ltiples argumentos   | 22/05/24      |
|                                          |               |
| Iteraciones sin salida                   |               |
|                                          |               |
| Operadores y otros funcionales           |               |
+------------------------------------------+---------------+

### Qui√©nes somos

![](images/1_N_0YimgDh2_IbBT9jJNtOg.jpg)

Coordinamos el [grupo de trabajo de Ecoinform√°tica](https://ecoinfaeet.github.io/website/index.html) de la Asociaci√≥n Espa√±ola de Ecolog√≠a Terrestre.

Y vosotros ¬øqui√©nes sois?

<https://www.menti.com/al2sdohesi5u>

## Introducci√≥n a la programaci√≥n en R

![El proceso de aprendizaje en R, por Allison Horst. https://allisonhorst.com/everything-else](images/e684f0da-13b1-4d00-ab25-37814e79ee1e.png){width="362"}

### Conceptos muy b√°sicos

-   R: lenguaje de programaci√≥n din√°mico (se interpreta el c√≥digo en el momento que se ejecuta).

-   RStudio: es un entorno de desarrollo integrado para programar en R. Tiene cuatro zonas diferenciadas: el editor de c√≥digo, la consola (donde se ejecuta el c√≥digo), el navegador del espacio de trabajo (con el entorno ‚Äì*environment-* y el historial de comandos) y el mix de abajo a la derecha (Archivos, Gr√°ficos, Paquetes, Ayuda).

-   Objetos: cualquier elemento almacenado con un nombre espec√≠fico. Pueden ser de muchos tipos: `numeric`, `integer`, `logical`, `data.frame`, `SpatVector`, etc.

-   Funciones: objetos de R que toman un vector de entrada y dan como resultado otro vector haciendo una acci√≥n concreta (funcionalidad espec√≠fica). Son los *bloques de construcci√≥n* fundamentales en cualquier script de R que es un lenguaje funcional.

    ![](images/function.png)

> Para comprender la computaci√≥n en R, resultan √∫tiles dos lemas:
>
> \- Todo lo que existe es un objeto.
>
> \- Todo lo que sucede es una llamada a funci√≥n.
>
> --- John Chambers ([Advanced R](https://adv-r.hadley.nz/index.html))

-   Paquetes o librerias: contienen funciones reutilizables, documentaci√≥n sobre c√≥mo usarlas y datos de ejemplo. Son las unidades fundamentales de c√≥digo reproducible en R.

-   CRAN: the Comprehensive R Archive Network.

```{r primeros_pasos_programacion}

3 + 2 # ejecuto un comando con CTRL+ENTER (CTRL+R)
15 / 20 * 100
1:50

sum(1:3) # funci√≥n y argumentos
?sum

# install.packages("palmerpenguins")
library(palmerpenguins) # la funcion library carga paquetes

palmerpenguins::penguins # :: permite explorar que hay dentro de los paquetes
# loadedNamespaces()

guau <- 2 # flecha de asignacion
guau # al ejecutar un objeto el nombre se sustituye por su contenido

guau + 4
miau <- guau + 4 + guau
miau

str(miau)

# objetos un poco m√°s complejos
miprimerdataframe <- data.frame(columna1 = guau,
  columna2 = miau)
str(miprimerdataframe)

miprimeralista <- list(elemento1 = guau,
  elemento2 = miau)
str(miprimeralista)
```

<!--# Vero: diferencias entre list/data.frame/matrix -->

#### Ejercicio

1.  Elije un n√∫mero y multiplicalo por 3

2.  Crea un objeto que contenga 100 valores entre 1900 y 2000

3.  Suma un n√∫mero a tu objeto

4.  Multiplica tu objeto por s√≠ mismo

üìùLos nombre de los objetos deben ser descriptivos y no pueden contener s√≠mbolos especiales (`^`, `!`, `$`, `@`, `+`, `-`, `/`, `*`).

üìùR es sensible a las may√∫sculas. Mejor no usarlas.

### Tidyverse

[*Tidyverse*](https://www.tidyverse.org/) es una colecci√≥n de paquetes (meta-paquete) de R desarrollado por Hadley Wickham. Contiene ocho paquetes principales: `readr`, `tibble`, `dplyr`, `tidyr`, `stringr`, `forcats`, `ggplot2` y `purrr`. *Tidyverse* puede considerarse un dialecto del lenguaje de programaci√≥n de R y, por ello, puede resultar dif√≠cil de aprender para gente con experiencia en el lenguaje tradicional de R base. Sin embargo, en este curso queremos ense√±ar las bases de programaci√≥n utilizando *tidyverse* ya que en las secciones de iteraci√≥n utilizaremos fundamentalmente `purrr` por razones que explicaremos m√°s adelante.

*Tidyverse* est√° dise√±ado para respaldar las actividades de un analista de datos humano por lo que sus estructuras de programaci√≥n resultan m√°s l√≥gicas para la mente humana. Todos los paquetes est√°n dise√±ados para trabajar con datos ordenados ([*tidy data*](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)), es decir, aquellos donde cada columna es una variable, cada fila una observaci√≥n y cada celda tiene un valor. Adem√°s, las funciones est√°n preparadas para concatenarse a trav√©s del operador *pipe* (`%>%` del paquete `magrittr` o `|>` de R base), que coge lo que est√° en su izquierda y lo utiliza como el primer argumento de la funci√≥n que est√° en su derecha. Esto permite seguir un flujo de lectura de izquierda a derecha, m√°s c√≥modo para la mayor√≠a de la gente.

üí°Los dos operador *pipe* tienen peque√±as [diferencias](https://www.tidyverse.org/blog/2023/04/base-vs-magrittr-pipe/) pero en general el comportamiento es el mismo.

```{r pipe}

mivector <- c(6, 4)
mean(mivector)
mivector |> 
  mean() # CTRL+SHIFT+M para poner un pipe

```

```{r primeros_tidypasos}
#| warning: false

# install.packages("tidyverse")
library(tidyverse)

penguins <- palmerpenguins::penguins
penguins

summary(penguins)
glimpse(penguins)
View(penguins)

# filter
penguins |> 
  filter(island == "Dream") 
penguins |> 
  filter(island == "Dream" & body_mass_g > 4500) # se pueden combinar criterios
penguins |> 
  filter(island == "Dream" | body_mass_g > 4500) 
penguins |> 
  filter(island %in% c("Dream", "Torgersen"))

# select
penguins |> 
  select(sex, body_mass_g)
penguins |> 
  select(ends_with("mm")) # seleccionar variables que tienen un patron
penguins |> 
  select(ends_with(c("mm", "g"))) 

# se pueden utilizar todo tipo de patrones de texto: https://rstudio.github.io/cheatsheets/strings.pdf

penguins |> 
  select(sex, body_mass_g, everything()) # se puede usar para reordenar variables

# arrange
penguins |> 
  select(sex, body_mass_g) |> 
  arrange(body_mass_g)
penguins |> 
  select(sex, body_mass_g) |> 
  arrange(desc(body_mass_g))
```

#### Ejercicio

1.  Crea un objeto con los ping√ºinos de la especie Adelie y ordena la tabla seg√∫n la longitud del ala de los individuos.

2.  Crea un objeto a partir del anterior donde selecciones la isla y las variables relacionadas con el pico.

3.  Crea un objeto a partir del creado en el punto 1 donde selecciones todo menos la especie.

```{r segundos_tidypasos}

# mutate
penguins |> 
  mutate(bill_volume_mm2 = (bill_length_mm * bill_depth_mm) / 2) |> 
  select(bill_volume_mm2, everything())

penguins |>
  mutate(female_penguin = case_when(
    sex == "female" & body_mass_g < 3600 ~ "small female",
    sex == "female" & body_mass_g >= 3600 ~ "big female",
    TRUE ~ NA)) |>
  select(female_penguin, sex, body_mass_g)

# summarise
# se utiliza con funciones que resumen: n, n_distinct, mean, etc.
# ver ?summarise

penguins |> 
  summarise(
    body_min = min(body_mass_g, na.rm = TRUE),
    body_max = max(body_mass_g, na.rm = TRUE)
  )

penguins |> 
  group_by(sex) |> 
  summarise(body_min = min(body_mass_g, na.rm = TRUE),
  body_max = max(body_mass_g, na.rm = TRUE))
```

#### Ejercicio

1.  Con el `data.frame` penguins, cuenta el n√∫mero de casos que hay en cada isla y calcula la media de la longitud del ala en cada isla.

2.  Con el mismo `data.frame` calcula la relaci√≥n entre el peso en kg y la longitud del ala.

```{r save_read_tidyverse}
#| eval: false
mypenguins <- penguins |> 
  mutate(bill_volume_mm2 = (bill_length_mm * bill_depth_mm) / 2,
    female_penguin = case_when(
      sex == "female" & body_mass_g < 3600 ~ "small female",
      sex == "female" & body_mass_g >= 3600 ~ "big female",
      TRUE ~ NA)) 

write_delim(mypenguins, file = "mypenguins.csv", delim = ";")
# en file hay que especificar el directorio donde queremos que se guarde. Si no, se guardar√° en el directorio de trabajo (getwd())

misdatos <- read_delim(file = "mypenguins.csv")
View(misdatos)
```

Una diferencia fundamental entre R base y *tidyverse* importante para avanzar en este curso es que el *name masking* es diferente. En R, si un argumento no est√° definido en una funci√≥n, R buscar√° ese nombre en el nivel del entorno inmediatamente superior. En general, con R base s√≥lo podemos llamar a objetos que forman parte del entorno (env-variables); en cambio, con tidyverse se puede llamar tambi√©n a las variables dentro de las tablas (data-variables). Esta caracter√≠stica simplifica el c√≥digo en tidyverse, pero la ventaja no tiene coste cero y tiene implicaciones en la gram√°tica de las funciones como veremos m√°s adelante.

üí°El [*lexical scoping* (√°mbito l√©xico)](https://adv-r.hadley.nz/functions.html?q=lexica#lexical-scoping) son el conjunto de normas sobre c√≥mo los valores de las variables son extraidos del entorno en cada lenguaje de programaci√≥n, es decir, como se asocia una variable a un valor. En R tiene cuatro normas b√°sicas, pero la m√°s importante para empezar con programaci√≥n funcional es el *name masking*.

```{r name_masking}
#| warning: false
#| error: true

mean(x = 1:10)
mean(x = valores)
misdatos <- data.frame(valores = 1:10)
mean(x = valores)
mean(x = misdatos$valores)
misdatos |> 
  summarise(mean = mean(valores))


penguins |> filter(island == "Dream", species == "Chinstrap") |> select(flipper_length_mm)
penguins[penguins$island == "Dream" & penguins$species == "Chinstrap", "flipper_length_mm"]

```

## Introducci√≥n a la programaci√≥n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an√°lisis han provocado el incremento en la cantidad y complejidad de los an√°lisis que realizamos en ecolog√≠a. Esto hace cada vez m√°s necesaria la eficiencia en el proceso de gesti√≥n y an√°lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci√≥n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c√≥digo.

Se puede llamar a una funci√≥n a trav√©s de otra funci√≥n e iterar el proceso lo que hace que R sea una herramienta muy potente. Las **iteraciones** sirven para realizar la misma acci√≥n a m√∫ltiples entradas. Existen dos grandes paradigmas de iteraci√≥n: la programaci√≥n orientada a objetos y la programaci√≥n funcional. En este taller, nos centraremos principalmente en la **programaci√≥n funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo_importancia_PF}
#| warning: false

df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

df_rescaled1 <- df |> 
  mutate(bill_length_mm = (bill_length_mm - min(bill_length_mm, na.rm = TRUE)) / (max(bill_length_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    bill_depth_mm = (bill_depth_mm - min(bill_depth_mm, na.rm = TRUE)) / (max(bill_depth_mm, na.rm = TRUE) - min(bill_length_mm, na.rm = TRUE)),
    flipper_length_mm = (flipper_length_mm - min(flipper_length_mm, na.rm = TRUE)) / (max(flipper_length_mm, na.rm = TRUE) - min(flipper_length_mm, na.rm = TRUE)),
    body_mass_g = (body_mass_g - min(body_mass_g, na.rm = TRUE)) / (max(body_mass_g, na.rm = TRUE) - min(body_mass_g, na.rm = TRUE)))
    
View(df_rescaled1)

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

df_rescaled2 <- df |> 
  mutate(bill_length_mm = rescale01(bill_length_mm),
    bill_depth_mm = rescale01(bill_depth_mm),
    flipper_length_mm = rescale01(flipper_length_mm), 
    body_mass_g = rescale01(body_mass_g))  

View(df_rescaled2)

#
df_rescaled3 <- lapply(df, rescale01)

head(df_rescaled3$bill_length_mm)

```

Las principales **ventajas de la programaci√≥n funcional** (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci√≥n del c√≥digo y, por tanto, mejorar la **comprensi√≥n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c√≥digo queda m√°s ordenado.
-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
-   **Disminuye la probabilidad de error**.

### ¬øCu√°ndo hay que usar una funci√≥n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci√≥n debe tener una representaci√≥n √∫nica, inequ√≠voca y autoritativa en un sistema.

Escribir una funci√≥n ya merece la pena cuando has copiado y pegado m√°s de dos veces lo mismo. Cuantas m√°s veces est√© repetido un c√≥digo en m√°s sitios necesitar√°s actualizarlo si hay algun cambio y m√°s aumenta la probabilidad de error.

## Teor√≠a sobre funciones en R

Las funciones tienen tres componentes:

-   `body()` (*cuerpo*): c√≥digo dentro de la funci√≥n.
-   `formals()`: lista de *argumentos* que controlan como se ejecuta la funci√≥n.
-   `environment()`: la estructura que alimenta el *scoping* de la funci√≥n, es decir, el *entorno* donde se ubica la funci√≥n.

```{r componentes}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

```{r environment}

f <- function(x) {
  x + y
}

y <- 100
f(x = 10)

y <- 1000
f(10)

```

Las **funciones primitivas** son la excepci√≥n ya que no tienen los citados componentes. Est√°n escritas en C en lugar de en R y s√≥lo aparecen en el paquete *base*. Son m√°s eficientes pero se comportan diferente a otras funciones, as√≠ que R Core Team intenta no crear nuevas funciones primitivas. El resto de funciones siguen la estructura indicada arriba.

```{r funciones_primitivas}

sum
body(sum)

```

Seg√∫n el tipo de output generado hay dos tipos de funciones:

-   Las **funciones de transformaci√≥n** transforman el objeto que entra en la funci√≥n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci√≥n.

-   Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci√≥n, como guardar un archivo o dibujar un plot. Algunos ejemplos que se usan comunmente son: `library()`, `setwd()`, `plot()`, `write_delim()`... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un *pipeline*.

En general, sint√°cticamente, las funciones tienen tres componentes:

-   Funci√≥n `function()` (primitiva)
-   Argumentos: lista de entradas.
-   Cuerpo: trozo de c√≥digo que sigue a `function()`, tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_")
}  

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")  

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")  

nombre1_v1("Vero", "Cruz") 
nombre1_v2("Vero", "Cruz") 
nombre1_v3("Vero", "Cruz") 

```

üìù Si la funci√≥n tiene m√°s de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir sola pero s√≠ la de cierre (excepto con *else*). Las sangr√≠as tambi√©n ayudan mucho a entender la jerarqu√≠a del c√≥digo dentro de las funciones. En este sentido recomendamos usar *Code \> Reindent lines/Reformat code* en el men√∫ de RStudio.

üí°Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisi√≥n (`[ ]`, `$`), de reemplazo (`<-`) o incluso las llaves (`{ }`) tambi√©n son funciones. La tilde invertida "\`" permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r nombres_ilegales}

3 + 2 
`+`(3, 2)  
for (i in 1:2) print(i) 
`for`(i, 1:2, print(i)) 
```

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an√≥nimas** para iterar.

```{r funciones_anonimas}

nxcaso <- lapply(penguins, function(x) length(unique(x)))

models <- penguins|>
  group_split(species) |>
  map(\(df) lm(body_mass_g ~ bill_length_mm, data = df)) 

```

üìù Mejor reservar el uso de funciones an√≥nimas para funciones cortas y simples. Si la funci√≥n es larga y ocupa varias l√≠neas mejor darle un nombre.

## C√≥mo escribir funciones

#### Ejercicio

Genera tu primera funci√≥n que divida un valor siempre entre 100.

üí°Atajo para escribir funciones: escribir la palabra fun + tabulador

Imaginad que para un set de datos quisieramos hacer un gr√°fico de distribuci√≥n de cada variable num√©rica, en funci√≥n de otra variable categ√≥rica que nos interese especialmente, para ver c√≥mo se distribuye.

```{r codigo_repetido_avanzado}
#| warning: false

penguins_num <- penguins |> 
  select(species, sex, where(is.numeric))

# nos interesan las diferencias entre especie y sexo

ggplot(penguins_num, aes(x = species, y = bill_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = bill_depth_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins_num, aes(x = species, y = flipper_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

# etc
```

Hemos copiado un c√≥digo m√°s de dos veces para realizar una misma acci√≥n (es decir, un gr√°fico para ver como se distribuye una variable en funci√≥n de otras dos que se mantienen constantes) as√≠ que hay que considerar la posibilidad de que estamos necesitando una funci√≥n. A continuaci√≥n vamos a seguir unos sencillos pasos para transformar cualquier c√≥digo repetido en funci√≥n.

1.  Analizar el c√≥digo: ¬øcu√°les son las partes replicadas? ¬øcuantas entradas tenemos? ¬øcu√°les var√≠an y cu√°les no?

2.  Simplificar y reanalizar duplicaciones

```{r funcion_simplificar}
#| warning: false

var <- penguins_num$bill_length_mm

ggplot(penguins_num, aes(x = species, y = var, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()
 
```

```{r funcion_simplificar_2}
#| warning: false
#| error: true

var <- body_mass_g
var <- "body_mass_g"

ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light() +
  ylab(var)


```

üëÄ La funci√≥n ggplot necesita argumentos (data-variable) que est√©n dentro del `data.frame` que va a representar. Para poder generalizar la funci√≥n hemos guardado el nombre de la variable en un objeto (tipo *character*), pero ggplot no acepta "characters". Por ello necesitamos utilizar una funci√≥n intermedia que s√≠ los acepte.

üìù Crear objetos con c√°lculos intermedios dentro de una funci√≥n, es una buena pr√°ctica porque deja m√°s claro lo que el c√≥digo est√° haciendo.

3.  Elegir un nombre para la funci√≥n (üìù). Idealmente tiene que ser corto y evocar lo que la funci√≥n hace. En general, debe ser un verbo (p.e. imputar_valores) mientras que los argumentos son sustantivos (p.e. data, variable, etc.). Usar un sustantivo para una funci√≥n est√° permitido si la funci√≥n calcula algo muy conocido (p.e. `mean()`) o si sirve para acceder a partes de un objeto (p.e. `residuals()`). Tambi√©n se recomienda evitar verbos muy gen√©ricos (p.e. calcular) y si el nombre tiene varias palabras separarlas con gui√≥n bajo o may√∫sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p.e. "str\_" en el paquete {stringr}).

Cuanto m√°s claramente puedas expresar la intenci√≥n de tu c√≥digo a trav√©s de los nombres de funciones, m√°s f√°cilmente otros e incluyendo tu mismo en el futuro podr√°n leer y comprender el c√≥digo.

```{r nombres_mal}

# Ejemplos de nombres que no hay que usar

T <- FALSE
c <- 10
mean <- function(x) sum(x)

rm(T, c, mean)

```

4.  Enumerar los argumentos dentro de `function()` y poner el c√≥digo simplificado dentro de las llaves.

```{r funcion_escribir}

# Varias opciones

explorar_penguins <- function (var) {
  ggplot(penguins_num, aes(x = species, y = .data[[var]], color = sex)) +
    geom_point(position = position_jitterdodge(), alpha = 0.3) +
    geom_boxplot(alpha = 0.5) +
    scale_color_manual(values = c("turquoise", "goldenrod1")) +
    theme_light() +
    ylab(var) 
}

```

üìù Utiliza comentarios (#) para explicar el razonamiento detr√°s de tus funciones. Se debe evitar explicar qu√© se est√° haciendo o c√≥mo, ya que el propio c√≥digo ya lo comunica. Tambi√©n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar con entradas diferentes

```{r funcion_pruebas}

explorar_penguins(var = "body_mass_g") 
explorar_penguins(var = "flipper_length_mm") 
explorar_penguins(var = "bill_depth_mm")

```

üí°Puedes querer convertir estas pruebas en **test** formales. En funciones complejas sirven para que, aunque hagas cambios, se pueda comprobar que la funcionalidad no se ha roto. Si est√°s interesado mira este enlace: [https://r-pkgs.org/testing-basics.html](#0){.uri}

#### Ejercicio

Genera una funci√≥n para estandarizar (es decir, restar la media y dividir por la desviaci√≥n t√≠pica) las variables num√©ricas de penguins.

### Argumentos

En general hay dos grupos: los que especifican los **datos** y los que especifican **detalles** de la ejecuci√≥n de la funci√≥n. Normalmente los que especifican datos se colocan primero y los de detalle despu√©s. Estos √∫ltimos suelen tener valores por defecto (los m√°s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

üìù Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que ya son conocidos para la mayor√≠a de los usuarios y est√° bien aprovecharlos:

`x, y, z`: vectores

`w`: vector de pesos

`df`: data frame

`i, j`: indices numericos, filas y columnas respectivamente

`n`: longitud o n√∫mero de filas

`p`: numero de columnas

`na.rm`: valores faltantes

A la hora de ejecutar la funci√≥n los argumentos se pueden **especificar** utilizando el nombre completo, una abreviatura unequ√≠voca o el √≥rden de su posici√≥n (*unnamed arguments*), siendo esta secuencia (nombre \> abreviatura \> posici√≥n) el √≥rden de prioridad a la hora de hacer corresponder los argumentos con lo que se escribe.

üìù Generalmente s√≥lo se usa el orden de posici√≥n para especificar los primeros argumentos, los m√°s comunes que todo el mundo conoce. Si se cambia un argumento de detalle con valor por defecto conviene poner siempre el combre completo.

üìù Usar espacios antes y despu√©s de `=` y despu√©s de `,` hace mucho m√°s f√°cil identificar los argumentos de la funci√≥n y, en general, todos los componentes.

```{r espacios}

set.seed(123)
mean(rnorm(10, mean = 50, sd = 25) / 12, trim = 0.2)

set.seed(123)
mean(rnorm(10,mean=50,sd=25)/12,trim=0.2)

```

Hay un argumento especial llamado `‚Ä¶`, que captura cualquier otro argumento que no se corresponde con los nombrados en la funci√≥n. Se utiliza para transmitir argumentos a otras funciones incluidas en nuestra funci√≥n.

```{r argumento_dotdotdot}
#| eval: false

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de title()")

```

üìù Usar `‚Ä¶` hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentaci√≥n para poder usarlo. Adem√°s, si se escribe mal un argumento no sale error.

```{r dotdotdot_flexibilidad}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

### Valores de retorno

La √∫ltima expresi√≥n ejecutada en una funci√≥n es el valor de retorno. Es el resultado de ejecutar la funci√≥n, a no ser que se especifique `invisible()`. Las funciones arrojan un s√≥lo objeto. Si se quieren obtener m√°s, tendr√° que ser en formato de lista.

<!--# Se os ocurre alg√∫n caso donde usar invisible? -->

üìù La funci√≥n `return()` se usa para indicar explicitamente qu√© se quiere obtener en una funci√≥n. Se recomienda su uso cuando el retorno no se espera al final de la funci√≥n. P.e. en las ramas de una estructura `if/else()` sobre todo hay alguna rama larga y compleja.

#### Ejercicio

¬øC√≥mo generalizar√≠as la funci√≥n `explorar_penguins()` para que te sirviera para cualquier base de datos?

## Programaci√≥n orientada a objetos (POO)

La mayor√≠a de la gente tiende a programar de forma imperativa. En la programaci√≥n imperativa, los scripts tienden a ser largos y cambian gradualmente el estado del programa. Esto a menudo implica el uso de bases de datos temporales que se modifican a lo largo del proceso de an√°lisis. Como resultado, puede resultar m√°s dif√≠cil comprender qu√© se est√° haciendo en cada paso del script. La programaci√≥n orientada a objetos, utilizada por lenguajes como Java o Python, ha sido el paradigma de programaci√≥n m√°s popular en las √∫ltimas d√©cadas y utiliza un estilo de programaci√≥n imperativo.

```{r cambio_gradual}

mypenguins <- penguins |> 
  mutate(
    bill_volume_mm2 = (bill_length_mm * bill_depth_mm) / 2,
    female_penguin = case_when(
      sex == "female" & body_mass_g < 3600 ~ "small female",
      sex == "female" & body_mass_g >= 3600 ~ "big female",
      TRUE ~ NA)
  ) 

mypenguins |> 
  group_by(female_penguin) |> 
  summarise(body_mass_mean = mean(body_mass_g))

```

Los bucles for y bucles while (*for loops* y *while loops*) son recomendables para adentrarse en el mundo de las iteraciones porque hacen que cada iteraci√≥n sea muy expl√≠cita por lo que est√° claro lo que est√° ocurriendo.

![Representaci√≥n gr√°fica del funcionamiento de los bucles for donde se ve claramente que se est√° realizando una iteraci√≥n. Ilustraci√≥n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/forloops.png)

```{r for}

set.seed(123)

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5)
)

salida <- vector("double", 3)           # 1. salida
for (i in 1:3) {                        # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])      # 3. cuerpo
}

salida

# podriamos generalizar el for
salida <- vector("double", ncol(df_ej))   # 1. salida
for (i in seq_along(df_ej)) {             # 2. secuencia
  salida[[i]] <- first(df_ej[[i]])        # 3. cuerpo
}

salida

```

1.  Salida: aqu√≠ determinamos el espacio de la salida, es decir, primero tenemos que crear la libreta donde vamos a ir apuntando todos los resultados. Esto es muy importante para la eficiencia puesto que si aumentamos el tama√±o del *for loop* en cada iteraci√≥n con `c()` u otra funci√≥n que vaya a√±adiendo elementos, el bucle for ser√° mucho m√°s lento.

```{r optimizacion}

x <- c()
system.time(
  for(i in 1:20000) {
    x <- c(x, i)
  }
)

y <- vector("double", length = 20000)
system.time(
  for(i in seq_along(y)) {
    y[i] <- i
  }
)

```

2.  Secuencia: aqu√≠ determinamos sobre lo que queremos iterar. Cada ejecuci√≥n del bucle for asignar√° un valor diferente de `seq_along(y)` a *i* .

3.  Cuerpo: aqu√≠ determinamos lo que queremos que haga cada iteraci√≥n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existen distintas [variaciones de los bucles for](https://r4ds.had.co.nz/iteration.html#for-loop-variations): (i) modificar un objeto existente en lugar de crear un nuevo; (ii) bucles sobre nombres o valores en lugar de sobre √≠ndices; (iii) bucles cuando desconocemos la longitud de la salida; (iv) bucles cuando desconocemos la longitud de la secuencia de entrada, es decir, bucles while.

üëÄ Algunos [errores comunes](https://adv-r.hadley.nz/control-flow.html) cuando se utilizan bucles for (ver 5.3.1 Common pitfalls).

A pesar de ser muy utilizados en R, los bucles for no son tan importantes como pueden ser en otros lenguajes porque R es un lenguaje de programaci√≥n funcional. Esto significa que *es posible envolver los bucles for en una funci√≥n* y llamar a esa funci√≥n en vez de utilizar el bucle.

Existe la creencia de que los bucles for son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles*. En cambio, cada funcional ({purrr}, `apply`) est√° dise√±ado para una tarea espec√≠fica, por lo que en cuanto lo ves en el c√≥digo, inmediatamente sabes por qu√© se est√° utilizando. Es decir, la principal ventaja es su claridad al hacer que el c√≥digo sea m√°s f√°cil de escribir y de leer (ver este ejemplo avanzado para entenderlo: <https://adv-r.hadley.nz/functionals.html>, 9.3 Purrr style). Una vez que dominemos la programaci√≥n funcional, podremos solventar muchos problemas de iteraci√≥n con menos c√≥digo, m√°s facilidad y menos errores.

Los bucles pueden ser m√°s expl√≠citos en cuanto a que se ve claramente la iteraci√≥n, pero se necesita m√°s tiempo para entender qu√© se est√° haciendo. Por el contrario, los funcionales necesitan un paso m√°s de abstracci√≥n y pueden requerir tiempo hasta que los comprendamos. Lo m√°s importante es que soluciones el problema y poco a poco ir escribiendo c√≥digo cada vez m√°s sencillo y elegante. Ver @sec-POO para obtener m√°s informaci√≥n sobre programaci√≥n orientada a objetos.

> Para ser significativamente m√°s fiable, el c√≥digo debe ser m√°s transparente. En particular, las condiciones anidadas y los bucles deben considerarse con gran recelo. Las esctructuras de control complicados confunden a los programadores. El c√≥digo desordenado suele ocultar errores.
>
> --- Bjarne Stroustrup ([Advanced R](https://adv-r.hadley.nz/index.html))

## Programaci√≥n funcional

![Representaci√≥n gr√°fica del funcionamiento de `map()` donde el foco est√° en la operaci√≥n realizada. Ilustraci√≥n de Allison Horst obtenido de la charla de Hadley Wickham The Joy of Functional Programming (para ciencia de datos)](images/map_frosting.png)

En la programaci√≥n funcional, las funciones est√°n dise√±adas para realizar una √∫nica tarea espec√≠fica y luego se combinan llamando a estas funciones sucesivamente para el conjunto de datos. Una ventaja significativa de este enfoque es que estas funciones pueden ser reutilizadas en cualquier otro proyecto, lo que facilita la modularidad del c√≥digo. Adem√°s, cuando est√°n bien documentadas y son f√°cilmente testables, resulta sencillo comprender y mantener el programa.

R es un lenguaje de programaci√≥n funcional por lo que se basa principalmente en un estilo de resoluci√≥n de problemas centrado en funciones (<https://adv-r.hadley.nz/fp.html>). Un funcional es una funci√≥n que toma una funci√≥n como entrada y devuelve un vector u otro tipo de objeto como salida.

```{r ejemplo_funcional}

aleatorizacion <- function(f) {
  f(rnorm(5))
}

aleatorizacion(f = median)

```

Para programar un funcional, primero, solucionamos el problema para un elemento. Despu√©s, generamos una funci√≥n que nos permita envolver la soluci√≥n en una funci√≥n. Por √∫ltimo, *aplicamos la funci√≥n a todos los elementos que estamos interesados.* Es decir, dividimos los problemas grandes en problemas m√°s peque√±os y resolvemos cada tarea con una o m√°s funciones.

La ventaja de utilizar {purrr} en vez de bucles for es que ofrece una funci√≥n (funcional) para cada uno de los problemas comunes de manipulaci√≥n de datos y, por lo tanto, cada bucle for tiene su propia funci√≥n. Por ejemplo, para iterar sobre un argumento utilizamos la funci√≥n `map()` y para iterar sobre dos argumentos la funcion `map2()`. La familia `apply` de R base soluciona problemas similares, pero {purrr} es m√°s consistente y, por lo tanto, m√°s f√°cil de aprender.

Iteracionar sobre un vector es tan com√∫n que el paquete {purrr} proporciona una familia de funciones (la familia `map()`) para ello. Recordad que los data frames son listas de vectores de la misma longitud por lo que cualquier c√°lculo por filas o columnas supone iteracionar sobre un vector. Existe una funci√≥n en {purrr} para cada tipo de salida. Los sufijos indican el tipo de salida que queremos:

-   `map()` genera una lista.
-   `map_lgl()` genera un vector l√≥gico.
-   `map_int()` genera un vector de n√∫meros enteros.
-   `map_dbl()` genera un vector de n√∫meros decimales.
-   `map_chr()` genera un vector de caracteres.
-   `map_vec()` genera un tipo arbitrario de vector, como fechas y factores.

üí°¬ø[Por qu√© est√° funci√≥n se llama *map*](https://adv-r.hadley.nz/functionals.html#map)?

```{r map_foco}

map_int(df_ej, first)

df_ej |> 
  map_int(first)

salida <- vector("double", 3)
for (i in 1:3) {
  salida[[i]] <- first(df_ej[[i]])
}
salida

```

Comparando con un bucle, el foco est√° en la operaci√≥n que se est√° ejecutando (`first()`), y no en el c√≥digo necesario para iterar sobre cada elemento y guardar la salida.

## Iteraciones sobre un argumento

`map_*()` est√° vectorizado sobre un argumento, p. ej. `(x)`. La funci√≥n operar√° en todos los elementos de `x`, es decir, cada valor si `x` es un vector, cada columna si `x` es un `data.frame`, o cada elemento si `x` es una lista.

### Nuestro primer funcional: generando listas, `map()`

Toma un vector y una funci√≥n, llama a la funci√≥n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {
  x ^ 2
}

map(1:4, cuadratica)

lapply(X = 1:4, FUN = cuadratica)

# algun uso mas interesante 
glimpse(penguins)

# atajo para generar una funcion anonima
map(penguins, \(x) length(unique(x)))

# salida dataframe
map_df(penguins, \(x) length(unique(x)))

```

![](images/map.png)

#### Ejercicio

Generad un vector, una funci√≥n y aplicadle la funci√≥n a cada uno de los elementos del vector utilizando `map()`.

#### Implementaci√≥n de map()

```{r map_implementacion}

imple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

imple_map(1:4, cuadratica)

```

üí°Las funciones de {purrr} est√°n escritas en C para maximizar el rendimiento, conserva los nombres y admite algunos atajos (e.g. `\(x)`).

#### Ejercicio

Ahora que hab√©is entendido la l√≥gica de `map()`, detectad las diferencias entre las tres l√≠neas de c√≥digo siguientes. ¬øQu√© es lo que hace el funcional `map()`? ¬øQu√© diferencias detect√°is en el c√≥digo? ¬øY en la salida?

```{r argumentos_adicionales}

map(penguins, \(x) mean(x))
map(penguins, \(x) mean(x, na.rm = T)) # opcion 1
map(penguins, mean, na.rm = T) # opcion 2

```

Como hemos visto en el ejercicio anterior, si quisi√©ramos pasar argumentos adicionales a la funci√≥n que estamos utilizando dentro de `map()`, una opci√≥n ser√≠a mediante una funci√≥n an√≥nima (ver opci√≥n 1 del ejercicio anterior). Sin embargo, puesto que `map()` incluye `...` entre sus argumentos, tambi√©n podemos incluir los argumentos adicionales despu√©s de la funci√≥n que est√° dentro de `map()` de una forma mucho m√°s sencilla (ver opci√≥n 2 del ejercicio anterior).

### Nuestro segundo funcional: generando vectores, `map_*()`

#### Ejercicio

Dedicadle un par de minutos a entender lo que hacen las siguientes funciones:

```{r map_vectores}

penguins |> 
  select(where(is.numeric))
map_lgl(penguins, is.numeric)
penguins_num <- penguins[ , map_lgl(penguins, is.numeric)] 
map_dbl(penguins_num, median, na.rm = T)
map_chr(penguins, class)
map_int(penguins, \(x) length(unique(x)))
1:4 |> 
  map_vec(\(x) as.Date(ISOdate(x + 2024, 05, 13)))

```

Los argumentos que var√≠an para cada ejecuci√≥n se ponen antes de la funci√≥n y los argumentos que son los mismos para cada ejecuci√≥n se ponen despu√©s (p. ej. `na.rm = T`).

![](images/map+fix.png)

R base tiene dos funciones de la familia `apply()` que pueden devolver vectores: `sapply()` y `vapply()`. Recomendamos evitar `sapply()` porque intenta simplificar el resultado y elige un formato de salida por defecto, pudiendo devolver una lista, un vector o una matriz. `vapply()` es m√°s seguro porque permite indicar el formato de salida con FUN.VALUE. La principal desventaja de `vapply()` es que se necesitan especificar m√°s argumentos que en `map_*()`.

```{r vapply}

vapply(penguins_num, median, na.rm = T, FUN.VALUE = double(1))

```

Trabajar con listas es muy com√∫n en R. De echo el output por defecto de `map()` son listas. Sin embargo, las listas pueden resultar a veces desordenadas, p. ej., cuando perdemos el nombre de cada elemento de la lista. La funci√≥n [`nest()`](https://tidyr.tidyverse.org/reference/nest.html) de {tidyr} nos permite trabajar con listas-columnas en data frames, generando una fila para cada grupo definido por las columnas no anidadas (i.e. non-nested columns).

```{r map_ejemplo_avanzado}

glimpse(penguins)

# quitamos na's
penguins_nona <- penguins |>
  drop_na()

penguins_nested <- penguins_nona |>
  group_by(species) |>
  nest() |> # nest() genera lista-columna en data frames
  mutate(
    lm_obj = map(data, \(df) lm(
      bill_length_mm ~ body_mass_g,
      data = df))
  )

# seleccionar cada elemento de la lista
penguins_nested[["lm_obj"]]

penguins_nested |>
  pluck("lm_obj")

```

## Iteraciones sobre m√∫ltiples argumentos

### Nuestro tercer funcional: dos entradas, `map2()`

`map2()` est√° vectorizado sobre dos argumentos, e.g. `(x, y)`

```{r map2_ejemplo}

potencia <- function(base, exponente) {
  base ^ exponente
}

set.seed(123)

x <- sample(5)
y <- sample(5)

map2(x, y, potencia)

```

‚ö°¬°Importante! La primera iteraci√≥n corresponde al primer valor del vector `x` y al primer valor del vector `y`. La segunda iteraci√≥n corresponde al segundo valor del vector `x` y al segundo valor del vector `y`. No se hacen todas las combinaciones posibles entre ambos vectores.

![](images/map2.png)

```{r map2_implementacion}

imple_map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}

imple_map2(x, y, potencia)

```

#### Ejercicio {#sec-ejercicio-map2}

A partir del c√≥digo que se muestra a continuaci√≥n generad un `data.frame`, agregando una columna al `data.frame` con el nombre que le hemos asignado a cada lista.

```{r map_2_ejercicio}

penguins_list <- penguins |>
  group_split(species)

# asignamos nombres a las listas
names(penguins_list) <- c("p1", "p2", "p3")

# solucion al ejercicio
# map2_df(penguins_list, names(penguins_list), \(x, y)
#         mutate(x, nombre = y))

```

```{r map2_ejemplo_avanzado}

penguins_nested <- penguins |>
  group_by(species) |>
  nest() |> 
  mutate(
    lm_obj = map(data, \(df) lm(
      bill_length_mm ~ body_mass_g,
      data = df)),
    pred = map2(lm_obj, data,
                \(x, y) predict(x, y))
  )

# unnest()
penguins_nested |> 
  unnest(pred) |> 
  select(!c(data, lm_obj))

```

#### Ejercicio avanzado

Calculad la correlaci√≥n entre las predicciones guardadas en la lista-columna `pred` y `bill_length_mm`.

### Nuestro cuarto funcional: m√∫ltiples entradas, `pmap()`

Toma una lista con cualquier n√∫mero de argumentos de entrada.

```{r pmap_ejemplo}

# son analogos
map2(x, y, potencia)

pmap(list(x, y), potencia)

set.seed(123)

z <- sample(5)

?rnorm

pmap(list(n = x, mean = y, sd = z), rnorm)

```

üí°Si no nombramos los elementos de la lista, `pmap()` usar√° los elementos de la lista en su orden para los argumentos consecutivos de la funci√≥n. De todas formas, es una buena pr√°ctica nombrarlos para que quede muy claro lo que har√° la funci√≥n.

```{r pmap_ejemplo_pipe}

args3 <- list(mean = x, sd = y, n = z) 

args3 |> 
  pmap(rnorm)

```

![](images/pmap.png)

#### Ejercicio

Transformad el `map2()` que hab√©is generado en el ejercicio @sec-ejercicio-map2 a `pmap()`.

## Iteraciones sin salida

### Nuestro quinto funcional: `walk()`, `walk2()` y `pwalk()`

Cuando queremos utilizar funciones por sus efectos secundarios (*side effects*, p.ej. `ggsave()`) y no por su valor resultante. Lo importante es la acci√≥n y no el valor u objeto resultante en R.

#### Ejercicio

En base a lo que dice en la definici√≥n sobre la familia `walk()`, corred este c√≥digo y entended lo que hace.

```{r walk_ejemplo}

penguins_nested <- penguins |>
  group_by(species) |>
  nest()

penguins_nested_str <- penguins_nested |> 
  mutate(path = str_glue("penguins_{species}.csv"))

penguins_nested_str

walk2(penguins_nested_str$data, penguins_nested_str$path, write_csv)

```

#### Ejercicio avanzado

Generad un ejemplo donde utiliceis `walk2()` para guardar m√∫ltiples plot generados con `ggplot()`. Pista: la primera entrada ser√° el plot que quer√©is guardar y la segunda el nombre del archivo que le quer√©is dar.

## Operadores y otros funcionales

### M√°s variantes de `map()`

#### `modify()` e `imap()`

`modify()` e `imap()` tambi√©n son funcionales de la familia map. `modify()` es an√°logo a `map()` pero devuelve el mismo tipo de resultado que el tipo de entrada.

`imap()` sirve para iterar sobre indices, tanto indices num√©ricos como nombres. `imap(x, f)` es an√°logo a `map2(x, names(x), f)` cuando `x` tiene nombres y `map2(x, seq_along(x), f)` cuando no los tiene.

```{r modify_imap}

# modify
map(1:4, cuadratica)

modify(1:4, cuadratica)


# imap
map2(penguins, names(penguins), \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

imap(penguins, \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

df_ej <- data.frame(
  a = sample(1:5),
  b = sample(1:5),
  c = sample(1:5)
) 

colnames(df_ej) <- NULL

imap(df_ej, \(x, y) paste("La columna", y, "tiene", length(unique(x)), "valores unicos contando los NA's"))

```

En este curso no profundizamos en `modify()` e `imap()` porque con los dem√°s funcionales que hemos visto podemos abordar pr√°cticamente todos los problemas de iteraci√≥n. Sin embargo, si alguien est√° interesado puede consultar <https://adv-r.hadley.nz/functionals.html>, 9.4 Map variants.

üí°Ejemplos de algunas tareas espec√≠ficas con {purrr}: <https://r4ds.hadley.nz/iteration>

### Funcionales predicate y dem√°s

Los predicados son funciones que devuelven un solo TRUE o FALSE (p.ej., como `is.character()`). As√≠, un predicado funcional aplica un predicado a cada elemento de un vector: `keep()`, `discard()`, `some()`, `every()`, `detect()`, `detect_index()`... Para m√°s informaci√≥n ver: <https://r4ds.had.co.nz/iteration.html>, 21.9.1 Predicate functions.

```{r ejemplo_predicado_funcional}

penguins |> 
  keep(is.numeric)

penguins |> 
  discard(is.numeric)

penguins |> 
  every(is.numeric)

```

`dplyr::across()` es similar a `map()` pero en lugar de hacer algo con cada elemento de un vector, data frame o lista, hace algo con cada columna en un data frame.

`reduce()` es una forma √∫til de generalizar una funci√≥n que funciona con dos entradas (funci√≥n binaria) para trabajar con cualquier n√∫mero de entradas.

```{r extra}

penguins_scaled <- penguins |>
  mutate(across(where(is.numeric), scale))

ls <- list(
  age = tibble(name = c("Vero", "Julen"), age = c(100, 140)),
  sex = tibble(name = c("Vero", "Julen"), sex = c("F", "M")),
  height = tibble(name = c("Vero", "Julen"), height = c("180", "150"))
)

ls |> 
  reduce(full_join, by = "name")

```

#### Operadores funcionales

Cuando utilizamos las funciones `map()` para repetir muchas operaciones, aumenta la probabilidad de que una de esas operaciones falle y no obtengamos ninguna salida. {purrr} proporciona algunos operadores funcionales (*function operators*) en forma de adverbios para asegurar que un error no arruine todo el proceso: `safely()`, `possibly()`, `quietly()`. Para m√°s informaci√≥n ver: <https://r4ds.had.co.nz/iteration.html>, 21.6 Dealing with failure.

```{r ejemplo_operador_funcional}
#| error: true

x <- list(10, "b", 3)

x |> 
  map(log)

x |> 
  map(safely(log))

x |> 
  map(safely(log)) |> 
  transpose()

x |> 
  map(possibly(log, NA_real_))

```

#### Ejercicio

Aplicad cualquier variante de `map()` junto con un operador funcional a la base de datos penguins.

## M√°s informaci√≥n

### Paralelizaci√≥n

Se pueden emplear distintos n√∫cleos de la CPU (*Central Processing Unit*) para ejecutar el mismo proceso con diferentes conjuntos de datos en paralelo, lo que acelera tareas largas. Algunas tareas son especialmente adecuadas para la paralelizaci√≥n, como aquellas que son repetitivas y tienen poca o ninguna dependencia entre s√≠, salvo el origen de los datos de entrada, lo que permite dividirlas f√°cilmente en tareas paralelas. Estas tareas suelen ser aquellas que pueden ser resueltas mediante iteraciones como las que hemos visto anteriormente. En teor√≠a, el proceso se acelera en proporci√≥n al n√∫mero de cores no, pero en la pr√°ctica, hay que tener en cuenta otros factores como el tiempo consumido en transferir datos a cada proceso y el tiempo dedicado a reunir los resultados de los diferentes procesos.

R fue dise√±ado originalmente para ejecutarse en un solo proceso de CPU debido a que cuando se desarroll√≥, las CPU en general ten√≠an un √∫nico n√∫cleo y la computaci√≥n paralela no era tan com√∫n o no estaba tan desarrollada como lo est√° hoy en d√≠a. Por lo tanto, para aprovechar la paralelizaci√≥n en R, necesitamos recurrir a paquetes adicionales. Sin embargo, es importante tener en cuenta que estos paquetes pueden estar limitados en su uso a casos y tipos de datos espec√≠ficos.

```{r paralelizacion}
#| eval: false

library(parallel) # detectar numero de cores
library(future) # establecer numero de cores
library(furrr) # paralelizacion con map

detectCores()

# funcion para elevar al cubo un numero
cubo <- function(x) {
  Sys.sleep(1) # simulacion tarea computacionalmente intensiva
  return(x ^ 3)
}

# secuencial
tiempo_inicio <- Sys.time()
resultado <- map(1:10, cubo)
tiempo_final <- Sys.time()
cat("Tiempo de computaci√≥n:", round(tiempo_final - tiempo_inicio, 1), "segundos")

# establecer como vamos a resolver el proceso
# aqui utilizaremos 3 nucleos pero en funcion del numero de nucleos disponibles en tu pc se puede modificar
plan(multisession, workers = 3)

# future_map para ejecutarlo paralelamente
tiempo_inicio <- Sys.time()
resultado <- future_map(1:10, cubo)
tiempo_final <- Sys.time()
cat("Tiempo de computaci√≥n:", round(tiempo_final - tiempo_inicio, 1), "seconds\n")

# vemos que el tiempo de computacion se ha reducido casi a un 1/3 (aprox. 1/numero de cores)

```

La informaci√≥n aqu√≠ expuesta sobre programaci√≥n paralela est√° mucho m√°s ampliamente explicada en: <https://emf.creaf.cat/workflows/r_parallel_computing_tech_doc/>

### M√°s informaci√≥n sobre programaci√≥n orientada a objetos (POO) {#sec-POO}

> \- Todo lo que existe es un objeto.
>
> --- John Chambers
>
> \- Sin embargo, no todo es orientado a objetos

En R, la programaci√≥n funcional suele ser m√°s relevante que la POO, ya que frecuentemente se abordan problemas complejos descomponi√©ndolos en funciones simples en lugar de objetos simples.

La principal raz√≥n para utilizar la POO es el polimorfismo (del lat√≠n "muchas formas"). El polimorfismo permite a un desarrollador considerar la interfaz de una funci√≥n por separado de su implementaci√≥n, lo que facilita el uso de la misma funci√≥n con diferentes tipos de entrada. Para entender esto, probad a correr el siguiente c√≥digo.

```{r polimorfismo}

summary(penguins$bill_depth_mm)
summary(penguins$sex)

```

Podr√≠as pensar que `summary()` utiliza una serie de declaraciones `if-else` seg√∫n el tipo de los datos de entrada, pero en este caso solo el autor original podr√≠a a√±adir nuevas implementaciones. Sin embargo, un sistema de POO permite que cualquier desarrollador extienda la interfaz mediante la creaci√≥n de implementaciones para nuevos tipos de entrada.

En los sistemas de POO, el tipo de un objeto se denomina su clase y una implementaci√≥n espec√≠fica para una clase se conoce como m√©todo. En t√©rminos generales, una clase define las caracter√≠sticas de un objeto (¬øqu√© es?) y los m√©todos describen las acciones que ese objeto puede realizar (¬øqu√© hace?).

R base proporciona tres sistemas de POO (S3 ‚Äìque es la m√°s utilizada-, S4 y RC), aunque tambi√©n existen otros sistemas POO proporcionados por diferentes paquetes del CRAN.

```{r objetos}

library(sloop)

is.object(1:5) # objeto base pero no orientada a objetos
otype(1:5) # objeto base 
attr(1:5, "class") # no tienen clase

is.object(penguins) # orientada a objetos
otype(penguins) # S3
attr(penguins, "class") # tienen clase

ftype(summary) # funcion generica S3
# una funcion generica define la interfaz, que utiliza una implementacion (metodo) diferente dependiendo de la clase del argumento. Acuerdate de la idea del polimorfismo que hemos visto antes ;)

```

üí°Informaci√≥n m√°s detallada sobre [POO](https://adv-r.hadley.nz/oo.html) y [compromisos entre algunos sistemas de POO](https://adv-r.hadley.nz/oo-tradeoffs.html)

### Enlaces de inter√©s

-   [Hands-On Programming with R (basics)](https://rstudio-education.github.io/hopr/basics.html)

-   [R for data Science (functions)](https://r4ds.had.co.nz/functions.html)

-   [Advanced R (functions)](https://adv-r.hadley.nz/functions.html)

-   [R for data Science (iteration)](https://r4ds.had.co.nz/iteration.html)

-   [Advanced R (functionals)](https://adv-r.hadley.nz/functionals.html)

-   [purrr 1.0.0](https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/)

-   [Learn to purrr (Rebecca Barter)](https://www.rebeccabarter.com/blog/2019-08-19_purrr)

-   [Style guide](http://adv-r.had.co.nz/Style.html)

-   [Quince consejos para mejorar nuestro c√≥digo y flujo de trabajo con R](https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129)

-   [Parallel computation in R](https://emf.creaf.cat/workflows/r_parallel_computing_tech_doc/)

-   [Advanced R (Object-oriented programming)](https://adv-r.hadley.nz/oo.html)

Este taller est√° principalmente basado en la primera edici√≥n del libro [R for Data Science](https://r4ds.had.co.nz/) de Hadley Wickham & Garrett Grolemund y la segunda edici√≥n del libro [Advanced R](https://adv-r.hadley.nz/index.html) de Hadley Wickham.

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session_info}
Sys.time()
sessionInfo()
```

</details>
