---
title: "Programación funcional en R y como dejar de pensar en bucle"
author: Julen Astigarraga y Verónica Cruz-Alonso
date: 10/16/2023
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
---

![EcoInf](images/Logo_ecoinf_10.jpg) 

## Presentación

Los **objetivos** de este taller son:

\- aprender a escribir funciones

\- aplicar funciones en programación iterativa mediante el paquete {purrr} de {tidyverse}

\- aprender estilos de código que facilitan su comprensión

### Estructura del curso

| Bloques                                | Tiempo estimado |
|----------------------------------------|-----------------|
| Introducción                           | 15 min          |
| Funciones teoria                       | 15 min          |
| Funciones practica                     | 25 min          |
| Progamación imperativa vs. funcional   | 25 min          |
| Descanso                               | 15 min          |
| Iteraciones con purrr                  | 75 min          |

<!--# Faltan 10 min-->

### Quiénes somos

Y vosotros ¿quiénes sois?

![QR](images/mentimeter_qr_code.png) <https://www.menti.com/alyyd29vgomt>

### Introducción a la programación funcional

La creciente disponibilidad de datos y de versatilidad de los programas de análisis han provocado el incremento en la cantidad y complejidad de los análisis que realizamos en ecología. Esto hace cada vez más necesaria la eficiencia en el proceso de gestión y análisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programación basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el código.

Las **funciones** son objetos de R que toman un input y lo transforman en un output haciendo una acción concreta (funcionalidad específica). Son los *bloques de construcción* fundamentales en cualquier script de R que es un lenguaje funcional. 

![fun](images/function.png) 

"To understand computations in R, two slogans are helpful:
- Everything that exist is an object
- Everything that happens is a function call."
(John Chambers)

Se puede llamar a una función a través de otra función e iterar el proceso haciendo que R sea una herramienta muy potente. Las iteraciones sirven para realizar la misma acción a múltiples entradas. Existen dos grandes paradigmas de iteración: la programación imperativa y la programación funcional. En este taller, nos centraremos principalmente en la **programación funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo importancia PF}

# install.packages("tidyverse")
# install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)

glimpse(penguins)
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

#
df$bill_length_mm <- (df$bill_length_mm - min(df$bill_length_mm, na.rm = TRUE))/(max(df$bill_length_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$bill_depth_mm <- (df$bill_depth_mm- min(df$bill_depth_mm, na.rm = TRUE))/(max(df$bill_depth_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$flipper_length_mm <- (df$flipper_length_mm - min(df$flipper_length_mm, na.rm = TRUE))/(max(df$flipper_length_mm, na.rm = TRUE) - min(df$flipper_length_mm, na.rm = TRUE)) 
df$body_mass_g <- (df$body_mass_g - min(df$body_mass_g, na.rm = TRUE))/(max(df$body_mass_g, na.rm = TRUE) - min(df$body_mass_g, na.rm = TRUE))

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

rescale01(c(0, 5, 10)) 

df$bill_length_mm <- rescale01(df$bill_length_mm) 
df$bill_depth_mm <- rescale01(df$bill_depth_mm) 
df$flipper_length_mm <- rescale01(df$flipper_length_mm) 
df$body_mass_g <- rescale01(df$body_mass_g)  

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

lapply(df, rescale01)

```

Las principales ventajas de la programación funcional (uso de funciones e iteraciones) son:

-   Facilidad para ver la intención del código y, por tanto, mejorar la **comprensión** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El código queda más ordenado.

-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
    
<!--# Cambiar arriba la funcion rescale para que divida por la media -->
-   **Disminuye la probabilidad de error**. 

<!--# Enseñar error de arriba -->

💡Los bucles pueden ser más explícitos en cuanto a que se ve claramente la iteración, pero se necesita más tiempo para entender que se está haciendo.

### ¿Cuándo hay que usar una función?

Principio "do not repeat yourself" (DRY principle): cada unidad de conocimiento o información debe tener un representación única, inequívoca y autoritativa en un sistema.

Escribir una función ya merece la pena cuando has copiado y pegado más de dos veces lo mismo.

## Funciones

Las funciones tienen tres componentes:
-   `body()` (cuerpo): código dentro de la función.
-   `formals()`: lista de argumentos que controla como se puede llamar a la función.
-   `environment()`: localización de las variables que controlan la función.

```{r}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

First class?
Hay una excepción a esta norma que son las **funciones primitivas**. Están escritas en C en lugar de R y sólo aparecen en el paquete *base*. Son más eficientes pero se comportan diferente a otras funciones, así que R Core Team intenta no crear nuevas funciones primitivas. 

####Anomimas
- closure con enlace

####Funcionales

```{r}

sum
body(sum)

```

Sintácticamente, las funciones en general tienen tres componentes:
-   Nombre
-   Argumentos: lista de inputs.
-   Cuerpo: trozo de código que sigue a function(...), tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {paste(x, y, sep = "_")}

nombre1_v2 <- function(x, y) paste(x, y, sep = "_") #Si pilla mas de dos lineas mejor llave

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")

nombre1_v1("Vero", "Cruz")
nombre1_v2("Vero", "Cruz")
nombre1_v3("Vero", "Cruz")

```

💡Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisión (`[ ]`, `$`) o llaves (`{ }`) o de reemplazo (`<-`) también son funciones. La tilde invertida `\`` permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r}

3 + 2
`+`(3, 2)

for (i in 1:2) print(i)
`for`(i, 1:2, print(i))

```

R tiene dos tipos de funciones con una sintaxis especial, donde los argumentos no van después de llamar a la función. Los operadores infijos, en los que el nombre de la función se coloca en medio de los argumentos, y las funciones de reemplazo.

### Cómo estribir funciones

p.270

-   Analizar el código ¿cuantos imputs? ¿hay partes replicadas?

-   Simplificar

-   Elegir un buen nombre:
- Usar para funciones nombre de objetos puede hacer confuso el código y es mejor evitarlo

-   Enumerar los argumentos (inputs) dentro de function (arguments)

-   Poner el código simplificado dentro del cuerpo de la función (body)

-   Probar con inputs diferentes (hablar de los tests)

#### Argumentos

Los argumentos se pueden especificar utilizando el nombre completo, una abreviatura unequívoca o el órden de posición (*unnamed arguments*), siendo este el órden de prioridad a la hora de corresponder los argumentos con lo que se escribe.

📝 Generalmente sólo se usa el orden de posición para para los primeros uno o dos argumentos, los más comunes que todo el mundo conoce

Los argumentos pueden tener valores por defecto para cuando no se especifique nada y estar definidos por otros argumentos y funciones.

Hay un argumento especial llamado "...". Este argumento se corresponde con cualquier argumento no especificado y se utiliza para transmitir argumentos a otras funciones incluidas en nuestra función.

```{r}

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de par")

```

📝 Usar "..." hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentación para poder usarlo. Además, si se escribe mal un argumento no sale error.

```{r}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

#### Retornos

La última expresión evaluada en una función es el valor de retorno, el resultado de invocar la función, a no ser que se especifique `invisible()`.
Las funciones arrojan un sólo objeto. Si se quieren obtener más, tendrá que ser en formato de lista.

??ejemplo de invisible? p96

📝 La función `return()` se usa para indicar explicitamente que se quiere obtener. Se recomienda su uso cuando el retorno no se espera al final de la función. P.e. en un if else.

Las **funciones puras** son aquellas que no afectan el estado del mundo de ninguna manera excepto el valor que retornan. Es decir, no tienen *efectos colaterales*. Hay algunas excepciones notables,como por ejemplo: library(), setwd(), plot() y amiguitos, write.csv()...





### *Lexical scoping* (Ámbito léxico)

Viene de *lexing*, el proceso de convertir una secuencia de caracteres (como en un script o página web) en una secuencia de tokens léxicos (cadenas con un significado asignado y por lo tanto identificado). Hay 4 principios básicos en el ámbito léxico de R:

- Name masking: si un nombre no está definido en una función, R buscará en un nivel superior. Las funciones conservan su environment y por tanto los valores definidos en su interior.

- Functions vs. variables: encontrar funciones funciona igual que encontrar variables, excepto que si es obvio que estás buscando una función (p.e. `f(3)`), R ignorará los objetos.

- A fresh start: cada vez que se llama una función, se crea un nuevo environment para albergar la ejecución. Cada invocación es completamente independiente.

- Dynamic lookup: el ámbito léxico indica donde y cómo buscar valores pero no *cuándo*. R busca valores cuando se ejecuta la función, no cuando es creada, por lo que puede arrojar valores diferentes según lo que haya en el environment de ejecución.



Ejercicio 1: función básica

Datos titanic

Ejercicio 2: función más compleja para usar

## Información principal

-   R for data Science (functions): <https://r4ds.had.co.nz/functions.html>

-   Advanced R (functions): <https://adv-r.hadley.nz/functions.html>

-   R for data Science (iteration): <https://r4ds.had.co.nz/iteration.html>

-   Advanced R (functionals): <https://adv-r.hadley.nz/functionals.html>

-   purrr 1.0.0: <https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/>

-   Learn to purrr (Rebecca Barter): <https://www.rebeccabarter.com/blog/2019-08-19_purrr>

-   Sacando el máximo partido a Tidyverse: <https://github.com/Julenasti/intro_tidyverse/blob/main/04-scripts/intro_tidyverse.md>

-   R for Data Science (2e): <https://r4ds.hadley.nz/>

## No directamente relacionado pero útil

-   Style guide: <http://adv-r.had.co.nz/Style.html>

-   Quince consejos para mejorar nuestro código y flujo de trabajo con R: <https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129>
