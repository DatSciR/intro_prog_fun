---
title: "Programaci贸n funcional en R y como dejar de pensar en bucle"
author: Julen Astigarraga y Ver贸nica Cruz-Alonso
date: 10/16/2023
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
---

![](images/Logo_ecoinf_10.jpg)

## Presentaci贸n

Los **objetivos** de este taller son:

-   aprender a escribir funciones

-   aplicar funciones en programaci贸n iterativa mediante el paquete {purrr} de {tidyverse}

-   aprender estilos de c贸digo que facilitan su comprensi贸n ()

### Estructura del curso

| Bloques                               | Tiempo estimado |
|---------------------------------------|-----------------|
| Introducci贸n                          | 15 min          |
| Teor铆a sobre funciones                | 20 min          |
| C贸mo escribir funciones               | 20 min          |
| Programaci贸n imperativa vs. funcional | 25 min          |
| Descanso                              | 15 min          |
| Iteraciones con {purrr}               | 75 min          |

<!--# Faltan 10 min-->

### Qui茅nes somos

![](images/1_N_0YimgDh2_IbBT9jJNtOg.jpg)

Y vosotros 驴qui茅nes sois?

![QR](images/mentimeter_qr_code.png) <https://www.menti.com/alyyd29vgomt>

## Introducci贸n a la programaci贸n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an谩lisis han provocado el incremento en la cantidad y complejidad de los an谩lisis que realizamos en ecolog铆a. Esto hace cada vez m谩s necesaria la eficiencia en el proceso de gesti贸n y an谩lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci贸n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c贸digo.

Las **funciones** son objetos de R que toman un input y consiguen un output haciendo una acci贸n concreta (funcionalidad espec铆fica). Son los *bloques de construcci贸n* fundamentales en cualquier script de R que es un lenguaje funcional.

![](images/function.png)

> To understand computations in R, two slogans are helpful:
>
> \- Everything that exist is an object
>
> \- Everything that happens is a function call.
>
> --- John Chambers ([Advanced R](https://adv-r.hadley.nz/index.html))

Se puede llamar a una funci贸n a trav茅s de otra funci贸n e iterar el proceso lo que hace que R sea una herramienta muy potente. Las **iteraciones** sirven para realizar la misma acci贸n a m煤ltiples inputs. Existen dos grandes paradigmas de iteraci贸n: la programaci贸n imperativa y la programaci贸n funcional. En este taller, nos centraremos principalmente en la **programaci贸n funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo importancia PF}
#| warning: false

# install.packages("tidyverse")
# install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)

glimpse(penguins)

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

df$bill_length_mm <- (df$bill_length_mm - min(df$bill_length_mm, na.rm = TRUE))/(max(df$bill_length_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$bill_depth_mm <- (df$bill_depth_mm- min(df$bill_depth_mm, na.rm = TRUE))/(max(df$bill_depth_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$flipper_length_mm <- (df$flipper_length_mm - min(df$flipper_length_mm, na.rm = TRUE))/(max(df$flipper_length_mm, na.rm = TRUE) - min(df$flipper_length_mm, na.rm = TRUE)) 
df$body_mass_g <- (df$body_mass_g - min(df$body_mass_g, na.rm = TRUE))/(max(df$body_mass_g, na.rm = TRUE) - min(df$body_mass_g, na.rm = TRUE))

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

df$bill_length_mm <- rescale01(df$bill_length_mm) 
df$bill_depth_mm <- rescale01(df$bill_depth_mm) 
df$flipper_length_mm <- rescale01(df$flipper_length_mm) 
df$body_mass_g <- rescale01(df$body_mass_g)  

head(df)

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

rescaled_df <- lapply(df, rescale01)

head(rescaled_df[[1]])
head(rescaled_df[[4]])

```

Las principales **ventajas de la programaci贸n funcional** (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci贸n del c贸digo y, por tanto, mejorar la **comprensi贸n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c贸digo queda m谩s ordenado.

Los bucles pueden ser m谩s expl铆citos en cuanto a que se ve claramente la iteraci贸n, pero se necesita m谩s tiempo para entender que se est谩 haciendo.

-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
-   **Disminuye la probabilidad de error**.

<!--# Ense帽ar error de arriba -->

### 驴Cu谩ndo hay que usar una funci贸n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci贸n debe tener un representaci贸n 煤nica, inequ铆voca y autoritativa en un sistema.

Escribir una funci贸n ya merece la pena cuando has copiado y pegado m谩s de dos veces lo mismo. Cuantas m谩s veces est茅 repetido un c贸digo en m谩s sitios necesitar谩s actualizarlo si hay algun cambio y m谩s aumenta la probabilidad de error.

## Teor铆a sobre funciones en R

Las funciones tienen tres componentes:

-   `body()` (*cuerpo*): c贸digo dentro de la funci贸n.
-   `formals()`: lista de *argumentos* que controlan como se ejecuta la funci贸n.
-   `environment()`: la estructura que alimenta el *scoping* de la funci贸n, es decir, el *entorno* donde se ubica la funci贸n.

```{r componentes}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

El [*lexical scoping* (谩mbito l茅xico)](https://adv-r.hadley.nz/functions.html?q=lexica#lexical-scoping) son el conjunto de normas sobre c贸mo los valores de las variables son extraidos del entorno en cada lenguaje de programaci贸n, es decir, como se asocia una variable a un valor. En R tiene cuatro normas b谩sicas, pero la m谩s importante para empezar con programaci贸n funcional es el *name masking*: si un argumento no est谩 definido en una funci贸n, R buscar谩 ese nombre en el nivel del entorno inmediatamente superior.

```{r environment}

f <- function(x) {
  x + y
}

y <- 100
f(10)

y <- 1000
f(10)

```

Las **funciones primitivas** son la excepci贸n ya que no tienen los citados componentes. Est谩n escritas en C en lugar de en R y s贸lo aparecen en el paquete *base*. Son m谩s eficientes pero se comportan diferente a otras funciones, as铆 que R Core Team intenta no crear nuevas funciones primitivas. El resto de funciones siguen la estructura indicada arriba.

```{r}

sum
body(sum)

```

Seg煤n el tipo de output generado hay dos tipos de funciones:

-   Las **funciones de transformaci贸n** transforman el objeto que entra en la funci贸n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci贸n.

-   Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci贸n, como guardar un archivo o dibujar un plot. Algunos ejemplos que se usan comunmente son: library(), setwd(), plot(), write.csv()... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un pipeline.

Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisi贸n (`[ ]`, `$`), de reemplazo (`<-`) o incluso las llaves (`{ }`) tambi茅n son funciones. La tilde invertida "\`" permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r nombre ilegales}

3 + 2
`+`(3, 2)

for (i in 1:2) print(i)
`for`(i, 1:2, print(i))

```

En general, sint谩cticamente, las funciones tienen tres componentes:

-   Funci贸n `function()` (primitiva)
-   Argumentos: lista de inputs.
-   Cuerpo: trozo de c贸digo que sigue a `function()`, tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_") }  

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")  

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")  

nombre1_v1("Vero", "Cruz") 
nombre1_v2("Vero", "Cruz") 
nombre1_v3("Vero", "Cruz") 

```

 Si la funci贸n tiene m谩s de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir sola pero s铆 la de cierre (excepto con *else*). Las sangr铆as tambi茅n ayudan mucho a entender la jerarqu铆a del c贸digo dentro de las funciones. En este sentido recomendamos usar *Code \> Reindent lines/Reformat code* en el men煤 de RStudio.

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an贸nimas** para iterar.

```{r funciones anonimas}

nxcaso <- lapply(penguins, function(x) length(unique(x)))

models <- penguins %>%
  split(.$species) %>%
  map( ~ lm(body_mass_g ~ bill_length_mm, data = .)) #M茅todo abreviado donde solo se utiliza un lado de la f贸rmula de la funci贸n

```

## C贸mo escribir funciones

Imaginad que para un set de datos quisieramos hacer un gr谩fico de distribuci贸n de cada variable, en funci贸n de otra variable categ贸rica que nos interese especialmente, para ver como se distribuye.

```{r de codigo repetido a funcion}
#| warning: false

glimpse(penguins)

#Nos interesan las diferencias entre especie y sexo

ggplot(penguins, aes(x = species, y = bill_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = bill_depth_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = island, color = sex)) +
  geom_jitter() +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

#Etc
```

Hemos copiado un c贸digo m谩s de dos veces para realizar una misma acci贸n (es decir, un gr谩fico para ver como se distribuye una variable) as铆 que hay que considerar la posibilidad de que estamos necesitando una funci贸n. A continuaci贸n vamos a seguir unos sencillos pasos para transformar cualquier c贸digo repetido en funci贸n.

1.  Analizar el c贸digo: 驴cu谩les son las partes replicadas? 驴cuantos inputs tenemos? 驴cu谩les var铆an y cu谩les no?

2.  Simplificar y reanalizar duplicaciones

```{r de codigo repetido a funcion, simplificar}

var_cont <- penguins$bill_length_mm
var_cat <- penguins$island

ggplot(penguins, aes(x = species, y = var_cont, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = var_cat, color = sex)) +
  geom_jitter() +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()
 
```

```{r de codigo repetido a funcion, simplificar2}

var_cont <- penguins$bill_length_mm
var_cat <- penguins$island
miformato <- list(scale_color_manual(values = c("turquoise", "goldenrod1")),
                  theme_light())

ggplot(penguins, aes(x = species, y = var_cont, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  miformato
  
ggplot(penguins, aes(x = species, y = var_cat, color = sex)) +
  geom_jitter() +
  miformato
 
```

```{r de codigo repetido a funcion, simplificar3}

var <- "island"
miformato <- list(scale_color_manual(values = c("turquoise", "goldenrod1")),
                  theme_light())

p <- ggplot(penguins, aes(x = species, y = pull(penguins, var), color = sex)) +
  miformato

if (is.numeric(pull(penguins, var))) {
  
  p + 
    geom_point(position = position_jitterdodge(), alpha = 0.3) +
    geom_boxplot(alpha = 0.5) 
  
} else {
  
  p + 
    geom_jitter()
  
}
 
```

 Crear objetos con c谩lculos intermedios (en el ejemplo, el caso del objeto "p"), es una buena pr谩ctica porque deja m谩s claro lo que el c贸digo est谩 haciendo.

3.  Elegir un nombre para la funci贸n (). Idealmente tiene que ser corto y evocar lo que la funci贸n hace. En general, debe ser un verbo (p.e. imputar_valores) mientras que los argumentos son nombres (p.e. data, variable, etc.). Usar un nombre para una funci贸n est谩 permitido si la funci贸n calcula algo muy conocido (p.e. `mean()`) o si sirve para acceder a partes de un objeto (p.e. `residuals()`). Tambi茅n se recomienda evitar verbos muy gen茅ricos (p.e. calcular) y si el nombre tiene varias palabras separarlas con gui贸n bajo o may煤sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p.e. "str\_" en el paquete {stringr}).

```{r nombres que no hay que usar}

#Ejemplos de nombres que no hay que usar

T <- FALSE
c <- 10
mean <- function(x) sum(x)

rm(T, c, mean)

```

4.  Enumerar los argumentos dentro de function y poner el c贸digo simplificado dentro de las llaves.

```{r de codigo repetido a funcion, escribir funcion}

#Varias opciones

exp_plot <- function (var) {
  miformato <-
    list(scale_color_manual(values = c("turquoise", "goldenrod1")),
         theme_light())
  p <- ggplot(penguins, aes(x = species, y = pull(penguins, var), color = sex)) +
    ylab(var) +
    miformato
  if (is.numeric(pull(penguins, var))) {
    p +
      geom_point(position = position_jitterdodge(), alpha = 0.3) +
      geom_boxplot(alpha = 0.5)
    
  } else {
    p +
      geom_jitter()
    
  }
}

```

 Utiliza comentarios (#) para explicar el razonamiento detr谩s de tus funciones. Se debe evitar explicar qu茅 se est谩 haciendo o c贸mo, ya que el propio c贸digo ya lo comunica. Tambi茅n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar con inputs diferentes

```{r de codigo repetido a funcion, pruebas}

exp_plot(var = "island") 
exp_plot(var = "year") 
exp_plot(var = "body_mass_g") 

```

Puedes querer convertir estas pruebas en **test** formales. En funciones complejas sirven para que, aunque hagas cambios, se pueda comprobar que la funcionalidad no se ha roto. Si est谩s interesado mira este enlace: [https://r-pkgs.org/testing-basics.html](#0){.uri}

#### Ejercicio 1

Genera una funci贸n para escalar (es decir, restar la media y dividir por la desviaci贸n t铆pica) las variables num茅ricas de penguins.

### Argumentos

En general hay dos grupos: los que especifican los **datos** y los que especifican **detalles** de la ejecuci贸n de la funci贸n. Normalmente los que especifican datos se colocan primero y los de detalle despu茅s. Estos 煤ltimos suelen tener valores por defecto (los m谩s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

 Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que tambi茅n se suelen usar (p.e. x, w, df, n, p, etc.), adem谩s de otros que ya existen y que no conviene definir de nuevo (p.e. na.rm).

Los argumentos se pueden **especificar** utilizando el nombre completo, una abreviatura unequ铆voca o el 贸rden de su posici贸n (*unnamed arguments*), siendo esta secuencia (nombre \> abreviatura \> posici贸n) el 贸rden de prioridad a la hora de hacer corresponder los argumentos con lo que se escribe.

 Generalmente s贸lo se usa el orden de posici贸n para para los primeros argumentos, los m谩s comunes que todo el mundo conoce. Si se cambia un argumento de detalle con valor por defecto conviene poner siempre el combre completo.

 Usar espacios antes y despu茅s de "=" y despu茅s de "," hace mucho m谩s f谩cil identificar los argumentos de la funci贸n y, en general, todos los componentes.

```{r}

average <- mean(rnorm(10, mean = 50, sd = 25) / 12, trim = 0.2)

average<-mean(rnorm(10,mean=50,sd=25)/12,trim=0.2)

```

Hay un argumento especial llamado "...", que captura cualquier otro argumento que no se corresponde con los nombrados en la funci贸n. Se utiliza para transmitir argumentos a otras funciones incluidas en nuestra funci贸n.

```{r}

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de par")

```

 Usar "..." hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentaci贸n para poder usarlo. Adem谩s, si se escribe mal un argumento no sale error.

```{r}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

### Valores de retorno

La 煤ltima expresi贸n ejecutada en una funci贸n es el valor de retorno. Es el resultado de ejecutar la funci贸n, a no ser que se especifique `invisible()`. Las funciones arrojan un s贸lo objeto. Si se quieren obtener m谩s, tendr谩 que ser en formato de lista.

<!--# Se os ocurre alg煤n caso donde usar invisible? -->

 La funci贸n `return()` se usa para indicar explicitamente qu茅 se quiere obtener en una funci贸n. Se recomienda su uso cuando el retorno no se espera al final de la funci贸n. P.e. en las ramas de una estructura if/else sobre todo hay alguna rama larga y compleja.

#### Ejercicio 2

驴C贸mo generalizar铆as la funci贸n expplot para que te sirviera para cualquier base de datos y cualquier variable categ贸rica?

## Enlaces de inter茅s

-   R for data Science (functions): <https://r4ds.had.co.nz/functions.html>

-   Advanced R (functions): <https://adv-r.hadley.nz/functions.html>

-   R for data Science (iteration): <https://r4ds.had.co.nz/iteration.html>

-   Advanced R (functionals): <https://adv-r.hadley.nz/functionals.html>

-   purrr 1.0.0: <https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/>

-   Learn to purrr (Rebecca Barter): <https://www.rebeccabarter.com/blog/2019-08-19_purrr>

-   Sacando el m谩ximo partido a Tidyverse: <https://github.com/Julenasti/intro_tidyverse/blob/main/04-scripts/intro_tidyverse.md>

-   R for Data Science (2e): <https://r4ds.hadley.nz/>

-   Style guide: <http://adv-r.had.co.nz/Style.html>

-   Quince consejos para mejorar nuestro c贸digo y flujo de trabajo con R: <https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129>
