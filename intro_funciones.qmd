---
title: "Programaci贸n funcional en R y como dejar de pensar en bucle"
author: Julen Astigarraga y Ver贸nica Cruz-Alonso
date: 10/16/2023
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
---

![EcoInf](images/Logo_ecoinf_10.jpg) 

## Presentaci贸n

Los **objetivos** de este taller son:

\- aprender a escribir funciones

\- aplicar funciones en programaci贸n iterativa mediante el paquete {purrr} de {tidyverse}

\- aprender estilos de c贸digo que facilitan su comprensi贸n

### Estructura del curso

| Bloques                                | Tiempo estimado |
|----------------------------------------|-----------------|
| Introducci贸n                           | 15 min          |
| Funciones teoria                       | 15 min          |
| Funciones practica                     | 25 min          |
| Progamaci贸n imperativa vs. funcional   | 25 min          |
| Descanso                               | 15 min          |
| Iteraciones con purrr                  | 75 min          |

<!--# Faltan 10 min-->

### Qui茅nes somos

Y vosotros 驴qui茅nes sois?

![QR](images/mentimeter_qr_code.png) <https://www.menti.com/alyyd29vgomt>

### Introducci贸n a la programaci贸n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an谩lisis han provocado el incremento en la cantidad y complejidad de los an谩lisis que realizamos en ecolog铆a. Esto hace cada vez m谩s necesaria la eficiencia en el proceso de gesti贸n y an谩lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci贸n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c贸digo.

Las **funciones** son objetos de R que toman un input y lo transforman en un output haciendo una acci贸n concreta (funcionalidad espec铆fica). Son los *bloques de construcci贸n* fundamentales en cualquier script de R que es un lenguaje funcional. 

![fun](images/function.png) 

"To understand computations in R, two slogans are helpful:
- Everything that exist is an object
- Everything that happens is a function call."
(John Chambers)

Se puede llamar a una funci贸n a trav茅s de otra funci贸n e iterar el proceso haciendo que R sea una herramienta muy potente. Las iteraciones sirven para realizar la misma acci贸n a m煤ltiples entradas. Existen dos grandes paradigmas de iteraci贸n: la programaci贸n imperativa y la programaci贸n funcional. En este taller, nos centraremos principalmente en la **programaci贸n funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo importancia PF}

# install.packages("tidyverse")
# install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)

glimpse(penguins)
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

#
df$bill_length_mm <- (df$bill_length_mm - min(df$bill_length_mm, na.rm = TRUE))/(max(df$bill_length_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$bill_depth_mm <- (df$bill_depth_mm- min(df$bill_depth_mm, na.rm = TRUE))/(max(df$bill_depth_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$flipper_length_mm <- (df$flipper_length_mm - min(df$flipper_length_mm, na.rm = TRUE))/(max(df$flipper_length_mm, na.rm = TRUE) - min(df$flipper_length_mm, na.rm = TRUE)) 
df$body_mass_g <- (df$body_mass_g - min(df$body_mass_g, na.rm = TRUE))/(max(df$body_mass_g, na.rm = TRUE) - min(df$body_mass_g, na.rm = TRUE))

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

rescale01(c(0, 5, 10)) 

df$bill_length_mm <- rescale01(df$bill_length_mm) 
df$bill_depth_mm <- rescale01(df$bill_depth_mm) 
df$flipper_length_mm <- rescale01(df$flipper_length_mm) 
df$body_mass_g <- rescale01(df$body_mass_g)  

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

lapply(df, rescale01)

```

Las principales ventajas de la programaci贸n funcional (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci贸n del c贸digo y, por tanto, mejorar la **comprensi贸n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c贸digo queda m谩s ordenado.

-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.
    
<!--# Cambiar arriba la funcion rescale para que divida por la media -->
-   **Disminuye la probabilidad de error**. 

<!--# Ense帽ar error de arriba -->

Los bucles pueden ser m谩s expl铆citos en cuanto a que se ve claramente la iteraci贸n, pero se necesita m谩s tiempo para entender que se est谩 haciendo.

### 驴Cu谩ndo hay que usar una funci贸n?

Principio "do not repeat yourself" (DRY principle): cada unidad de conocimiento o informaci贸n debe tener un representaci贸n 煤nica, inequ铆voca y autoritativa en un sistema.

Escribir una funci贸n ya merece la pena cuando has copiado y pegado m谩s de dos veces lo mismo.

## Funciones

Las funciones tienen tres componentes:
-   `body()` (cuerpo): c贸digo dentro de la funci贸n.
-   `formals()`: lista de argumentos que controla como se puede llamar a la funci贸n.
-   `environment()`: localizaci贸n de las variables que controlan la funci贸n.

```{r}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

First class?
Hay una excepci贸n a esta norma que son las **funciones primitivas**. Est谩n escritas en C en lugar de R y s贸lo aparecen en el paquete *base*. Son m谩s eficientes pero se comportan diferente a otras funciones, as铆 que R Core Team intenta no crear nuevas funciones primitivas. 

####Anomimas
- closure con enlace

####Funcionales

```{r}

sum
body(sum)

```

Sint谩cticamente, las funciones en general tienen tres componentes:
-   Nombre
-   Argumentos: lista de inputs.
-   Cuerpo: trozo de c贸digo que sigue a function(...), tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {paste(x, y, sep = "_")}

nombre1_v2 <- function(x, y) paste(x, y, sep = "_") #Si pilla mas de dos lineas mejor llave

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")

nombre1_v1("Vero", "Cruz")
nombre1_v2("Vero", "Cruz")
nombre1_v3("Vero", "Cruz")

```

Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisi贸n (`[ ]`, `$`) o llaves (`{ }`) o de reemplazo (`<-`) tambi茅n son funciones. La tilde invertida `\`` permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r}

3 + 2
`+`(3, 2)

for (i in 1:2) print(i)
`for`(i, 1:2, print(i))

```

R tiene dos tipos de funciones con una sintaxis especial, donde los argumentos no van despu茅s de llamar a la funci贸n. Los operadores infijos, en los que el nombre de la funci贸n se coloca en medio de los argumentos, y las funciones de reemplazo.

### C贸mo estribir funciones

p.270

-   Analizar el c贸digo 驴cuantos imputs? 驴hay partes replicadas?

-   Simplificar

-   Elegir un buen nombre:
- Usar para funciones nombre de objetos puede hacer confuso el c贸digo y es mejor evitarlo

-   Enumerar los argumentos (inputs) dentro de function (arguments)

-   Poner el c贸digo simplificado dentro del cuerpo de la funci贸n (body)

-   Probar con inputs diferentes (hablar de los tests)

#### Argumentos

Los argumentos se pueden especificar utilizando el nombre completo, una abreviatura unequ铆voca o el 贸rden de posici贸n (*unnamed arguments*), siendo este el 贸rden de prioridad a la hora de corresponder los argumentos con lo que se escribe.

 Generalmente s贸lo se usa el orden de posici贸n para para los primeros uno o dos argumentos, los m谩s comunes que todo el mundo conoce

Los argumentos pueden tener valores por defecto para cuando no se especifique nada y estar definidos por otros argumentos y funciones.

Hay un argumento especial llamado "...". Este argumento se corresponde con cualquier argumento no especificado y se utiliza para transmitir argumentos a otras funciones incluidas en nuestra funci贸n.

```{r}

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de par")

```

 Usar "..." hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentaci贸n para poder usarlo. Adem谩s, si se escribe mal un argumento no sale error.

```{r}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

#### Retornos

La 煤ltima expresi贸n evaluada en una funci贸n es el valor de retorno, el resultado de invocar la funci贸n, a no ser que se especifique `invisible()`.
Las funciones arrojan un s贸lo objeto. Si se quieren obtener m谩s, tendr谩 que ser en formato de lista.

??ejemplo de invisible? p96

 La funci贸n `return()` se usa para indicar explicitamente que se quiere obtener. Se recomienda su uso cuando el retorno no se espera al final de la funci贸n. P.e. en un if else.

Las **funciones puras** son aquellas que no afectan el estado del mundo de ninguna manera excepto el valor que retornan. Es decir, no tienen *efectos colaterales*. Hay algunas excepciones notables,como por ejemplo: library(), setwd(), plot() y amiguitos, write.csv()...





### *Lexical scoping* (mbito l茅xico)

Viene de *lexing*, el proceso de convertir una secuencia de caracteres (como en un script o p谩gina web) en una secuencia de tokens l茅xicos (cadenas con un significado asignado y por lo tanto identificado). Hay 4 principios b谩sicos en el 谩mbito l茅xico de R:

- Name masking: si un nombre no est谩 definido en una funci贸n, R buscar谩 en un nivel superior. Las funciones conservan su environment y por tanto los valores definidos en su interior.

- Functions vs. variables: encontrar funciones funciona igual que encontrar variables, excepto que si es obvio que est谩s buscando una funci贸n (p.e. `f(3)`), R ignorar谩 los objetos.

- A fresh start: cada vez que se llama una funci贸n, se crea un nuevo environment para albergar la ejecuci贸n. Cada invocaci贸n es completamente independiente.

- Dynamic lookup: el 谩mbito l茅xico indica donde y c贸mo buscar valores pero no *cu谩ndo*. R busca valores cuando se ejecuta la funci贸n, no cuando es creada, por lo que puede arrojar valores diferentes seg煤n lo que haya en el environment de ejecuci贸n.



Ejercicio 1: funci贸n b谩sica

Datos titanic

Ejercicio 2: funci贸n m谩s compleja para usar

## Informaci贸n principal

-   R for data Science (functions): <https://r4ds.had.co.nz/functions.html>

-   Advanced R (functions): <https://adv-r.hadley.nz/functions.html>

-   R for data Science (iteration): <https://r4ds.had.co.nz/iteration.html>

-   Advanced R (functionals): <https://adv-r.hadley.nz/functionals.html>

-   purrr 1.0.0: <https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/>

-   Learn to purrr (Rebecca Barter): <https://www.rebeccabarter.com/blog/2019-08-19_purrr>

-   Sacando el m谩ximo partido a Tidyverse: <https://github.com/Julenasti/intro_tidyverse/blob/main/04-scripts/intro_tidyverse.md>

-   R for Data Science (2e): <https://r4ds.hadley.nz/>

## No directamente relacionado pero 煤til

-   Style guide: <http://adv-r.had.co.nz/Style.html>

-   Quince consejos para mejorar nuestro c贸digo y flujo de trabajo con R: <https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129>
