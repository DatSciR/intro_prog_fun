---
title: "Programaci贸n funcional en R y como dejar de pensar en bucle"
author: Julen Astigarraga y Ver贸nica Cruz-Alonso
date: 10/16/2023
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
---

![](images/Logo_ecoinf_10.jpg)

## Presentaci贸n

Los **objetivos** de este taller son:

\- aprender a escribir funciones

\- aplicar funciones en programaci贸n iterativa mediante el paquete {purrr} de {tidyverse}

\- aprender estilos de c贸digo que facilitan su comprensi贸n

### Estructura del curso

| Bloques                              | Tiempo estimado |
|--------------------------------------|-----------------|
| Introducci贸n                         | 15 min          |
| Funciones teoria                     | 15 min          |
| Funciones practica                   | 25 min          |
| Progamaci贸n imperativa vs. funcional | 25 min          |
| Descanso                             | 15 min          |
| Iteraciones con purrr                | 75 min          |

<!--# Faltan 10 min-->

### Qui茅nes somos

![](images/1_N_0YimgDh2_IbBT9jJNtOg.jpg)

Y vosotros 驴qui茅nes sois?

![QR](images/mentimeter_qr_code.png) <https://www.menti.com/alyyd29vgomt>

## Introducci贸n a la programaci贸n funcional

La creciente disponibilidad de datos y de versatilidad de los programas de an谩lisis han provocado el incremento en la cantidad y complejidad de los an谩lisis que realizamos en ecolog铆a. Esto hace cada vez m谩s necesaria la eficiencia en el proceso de gesti贸n y an谩lisis de datos. Una de las posibles formas para optimizar estos procesos y acortar los tiempos de trabajo para los usuarios de R es la programaci贸n basada en funciones. Las funciones permiten automatizar tareas comunes (por ejemplo, leer diferentes bases de datos) simplificando el c贸digo.

Las **funciones** son objetos de R que toman un input y consiguen un output haciendo una acci贸n concreta (funcionalidad espec铆fica). Son los *bloques de construcci贸n* fundamentales en cualquier script de R que es un lenguaje funcional.

![fun](images/function.png)

> To understand computations in R, two slogans are helpful:
>
> \- Everything that exist is an object
>
> \- Everything that happens is a function call.
>
> --- John Chambers ([Advanced R](https://adv-r.hadley.nz/index.html))

Se puede llamar a una funci贸n a trav茅s de otra funci贸n e iterar el proceso lo que hace que R sea una herramienta muy potente. Las iteraciones sirven para realizar la misma acci贸n a m煤ltiples entradas. Existen dos grandes paradigmas de iteraci贸n: la programaci贸n imperativa y la programaci贸n funcional. En este taller, nos centraremos principalmente en la **programaci贸n funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

```{r ejemplo importancia PF}

# install.packages("tidyverse")
# install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)

glimpse(penguins)
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

#
df$bill_length_mm <- (df$bill_length_mm - min(df$bill_length_mm, na.rm = TRUE))/(max(df$bill_length_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$bill_depth_mm <- (df$bill_depth_mm- min(df$bill_depth_mm, na.rm = TRUE))/(max(df$bill_depth_mm, na.rm = TRUE) - min(df$bill_length_mm, na.rm = TRUE)) 
df$flipper_length_mm <- (df$flipper_length_mm - min(df$flipper_length_mm, na.rm = TRUE))/(max(df$flipper_length_mm, na.rm = TRUE) - min(df$flipper_length_mm, na.rm = TRUE)) 
df$body_mass_g <- (df$body_mass_g - min(df$body_mass_g, na.rm = TRUE))/(max(df$body_mass_g, na.rm = TRUE) - min(df$body_mass_g, na.rm = TRUE))

#
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)   
  (x - rng[1]) / (rng[2] - rng[1]) 
} 

rescale01(c(0, 5, 10)) 

df$bill_length_mm <- rescale01(df$bill_length_mm) 
df$bill_depth_mm <- rescale01(df$bill_depth_mm) 
df$flipper_length_mm <- rescale01(df$flipper_length_mm) 
df$body_mass_g <- rescale01(df$body_mass_g)  

#
df <- penguins |> 
  select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)

lapply(df, rescale01)

```

Las principales ventajas de la programaci贸n funcional (uso de funciones e iteraciones) son:

-   Facilidad para ver la intenci贸n del c贸digo y, por tanto, mejorar la **comprensi贸n** para uno mismo, colaboradores y revisores:
    -   Las funciones tienen un nombre evocativo.
    -   El c贸digo queda m谩s ordenado.
-   **Rapidez** si se necesitan hacer cambios ya que las funciones son piezas independientes que resuelven un problema concreto.

<!--# Cambiar arriba la funcion rescale para que divida por la media -->

-   **Disminuye la probabilidad de error**.

<!--# Ense帽ar error de arriba -->

Los bucles pueden ser m谩s expl铆citos en cuanto a que se ve claramente la iteraci贸n, pero se necesita m谩s tiempo para entender que se est谩 haciendo.

### 驴Cu谩ndo hay que usar una funci贸n?

Se recomienda seguir el principio "do not repeat yourself" ([DRY principle](https://en.wikipedia.org/wiki/Don%27t_repeat_yourself#:~:text=%22Don't%20repeat%20yourself%22,redundancy%20in%20the%20first%20place.)): cada unidad de conocimiento o informaci贸n debe tener un representaci贸n 煤nica, inequ铆voca y autoritativa en un sistema.

Escribir una funci贸n ya merece la pena cuando has copiado y pegado m谩s de dos veces lo mismo. Cuantas m谩s veces est茅 repetido un c贸digo en m谩s sitios necesitar谩s actualizarlo si hay algun cambio.

## Funciones

Las funciones tienen tres componentes:

-   `body()` (cuerpo): c贸digo dentro de la funci贸n.
-   `formals()`: lista de argumentos que controla como se puede ejecutar la funci贸n.
-   `environment()`: la estructura que alimenta el *scoping* de la funci贸n, es decir, el entorno donde se ubica la funci贸n.

```{r}

body(rescale01)
formals(rescale01)
environment(rescale01)

```

El [*lexical scoping* (谩mbito l茅xico)](https://adv-r.hadley.nz/functions.html?q=lexica#lexical-scoping) son el conjunto de normas sobre c贸mo los valores de las variables son extraidos del entorno en cada lenguaje de programaci贸n, es decir, como se asocia una variable a un valor. En R tiene cuatro normas b谩sicas, pero la m谩s importante para empezar con programaci贸n funcional es que si un argumento no est谩 definido en una funci贸n, R buscar谩 ese nombre en el nivel del entorno inmediatamente superior (*name masking*).

```{r environment}

f <- function(x) {
x + y
}

y <- 100
f(10)

y <- 1000
f(10)

```

Hay una excepci贸n a esta norma que son las **funciones primitivas**. Est谩n escritas en C en lugar de R y s贸lo aparecen en el paquete *base*. Son m谩s eficientes pero se comportan diferente a otras funciones, as铆 que R Core Team intenta no crear nuevas funciones primitivas. El resto de funciones siguen la estructura indicada arriba. Dentro de estas.

Seg煤n el tipo de output generado hay dos tipos de funciones: - Las **funciones de transformaci贸n** transforman el objeto que entra en la funci贸n (primer argumento) y devuelven otro objeto o el anterior modificado. Los funcionales son tipos especiales de funciones de transformaci贸n. - Las **funciones secundarias** (*side-effect functions*) tienen efectos colaterales y ejecutan una acci贸n, como guardar un archivo o dibujar un plot. Algunos ejemplos que se usan comunmente son: library(), setwd(), plot(), write.csv()... Estas funciones retornan *de forma invisible* el primer argumento, que no se guarda, pero puede ser usado en un pipeline.

```{r}

sum
body(sum)

```

Sint谩cticamente, las funciones en general tienen tres componentes:

-   Funci贸n `function()` (primitiva)
-   Argumentos: lista de inputs.
-   Cuerpo: trozo de c贸digo que sigue a function(...), tradicionalmente entre llaves.

```{r notaciones}

nombre1_v1 <- function(x, y) {
  paste(x, y, sep = "_")
}

nombre1_v2 <- function(x, y) paste(x, y, sep = "_")

nombre1_v3 <- \(x, y) paste(x, y, sep = "_")

nombre1_v1("Vero", "Cruz")
nombre1_v2("Vero", "Cruz")
nombre1_v3("Vero", "Cruz")

```

 Si la funci贸n tiene mas de dos lineas es mejor usar llaves siempre para que quede bien delimitada. La llave de apertura nunca debe ir s贸la (excepto con *else*) pero si la de cierre. Y por favor... 隆usad sangrias! (Code \> Reindent lines/Reformat code)

Los operadores infijos (`+`), de flujo (`for`, `if`), de subdivisi贸n (`[ ]`, `$`) o llaves (`{ }`) o de reemplazo (`<-`) tambi茅n son funciones. La tilde invertida \`\`\` permite referirse a funciones o variables que de otro modo tienen "nombre ilegales".

```{r}

3 + 2
`+`(3, 2)

for (i in 1:2) print(i)
`for`(i, 1:2, print(i))

```

R tiene dos tipos de funciones con una sintaxis especial, donde los argumentos no van despu茅s de llamar a la funci贸n. Los operadores infijos, en los que el nombre de la funci贸n se coloca en medio de los argumentos, y las funciones de reemplazo.

En general las funciones tienen un nombre que se ejecuta cuando se necesita como hemos visto hasta ahora, pero esto no es obligatorio. Algunos paquetes como {purrr} o las funciones de la familia `apply` permiten el uso de **funciones an贸nimas** para iterar.

```{r funciones anonimas}

lapply(penguins, function(x) length(unique(x)))

models <- penguins %>%
  split(.$species) %>%
  map( ~ lm(body_mass_g ~ bill_length_mm, data = .)) #M茅todo abreviado donde solo se utiliza un lado de la f贸rmula de la funci贸n

```

### C贸mo escribir funciones

Imaginad que para un set de datos quisieramos hacer un gr谩fico de distribuci贸n de cada variable, en funci贸n de una categ贸rica que nos interese especialmente, para ver como se distribuye.

```{r de codigo repetido a funcion}

glimpse(penguins)

#Nos interesan las diferencias entre especie y sexo

ggplot(penguins, aes(x = species, y = bill_length_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = bill_depth_mm, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = island, color = sex)) +
  geom_jitter() +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

#Etc
```

Hemos copiado un c贸digo m谩s de dos veces para realizar una misma acci贸n (es decir, un gr谩fico para ver como se distribuye una variable) as铆 que hay que considerar la posibilidad de que estamos necesitando una funci贸n. A continuaci贸n vamos a seguir unos sencillos pasos para transformar cualquier c贸digo repetido en funci贸n.

1.  Analizar el c贸digo: 驴cu谩les son las partes replicadas? 驴cuantos inputs tenemos? 驴cu谩les var铆an y cu谩les no?

2.  Simplificar y reanalizar duplicaciones

```{r de codigo repetido a funcion, simplificar}

var_cont <- penguins$bill_length_mm
var_cat <- penguins$island

ggplot(penguins, aes(x = species, y = var_cont, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()

ggplot(penguins, aes(x = species, y = var_cat, color = sex)) +
  geom_jitter() +
  scale_color_manual(values = c("turquoise", "goldenrod1")) +
  theme_light()
 
```

```{r de codigo repetido a funcion, simplificar2}

var_cont <- penguins$bill_length_mm
var_cat <- penguins$island
miformato <- list(scale_color_manual(values = c("turquoise", "goldenrod1")),
                  theme_light())

ggplot(penguins, aes(x = species, y = var_cont, color = sex)) +
  geom_point(position = position_jitterdodge(), alpha = 0.3) +
  geom_boxplot(alpha = 0.5) +
  miformato
  
ggplot(penguins, aes(x = species, y = var_cat, color = sex)) +
  geom_jitter() +
  miformato
 
```

```{r de codigo repetido a funcion, simplificar3}

var <- penguins$island
miformato <- list(scale_color_manual(values = c("turquoise", "goldenrod1")),
                  theme_light())

p <- ggplot(penguins, aes(x = species, y = var, color = sex)) +
  miformato

if (is.numeric(pull(penguins, var))) {
  
  p + 
    geom_point(position = position_jitterdodge(), alpha = 0.3) +
    geom_boxplot(alpha = 0.5) 
  
} else {
  
  p + 
    geom_jitter()
  
}
 
```

 Crear objetos con c谩lculos intermedios (en el ejemplo, el caso del objeto "p"), es una buena pr谩ctica porque deja m谩s claro lo que el c贸digo est谩 haciendo.

3.  Elegir un nombre para la funci贸n (). Idealmente tiene que ser corto y evocar lo que la funci贸n hace. En general, debe ser un verbo (p.e. imputar_valores) mientras que los argumentos son nombres (p.e. data, variable, etc.). Usar un nombre para una funci贸n est谩 permitido si la funci贸n calcula algo muy conocido (p.e. `mean()`) o si sirve para acceder a partes de un objeto (p.e. `residuals()`). Tambi茅n se recomienda evitar verbos muy gen茅ricos (p.e. calcular) y si el nombre tiene varias palabras separarlas con gui贸n bajo o may煤sculas, pero ser consistente. Si programas varias funciones que hacen cosas parecidas se recomienda usar el mismo prefijo para todas (p.e. "str\_" en el paquete {stringr}).

```{r de codigo repetido a funcion, no hacer}

#Ejemplos de nombres que no hacer

T <- FALSE
c <- 10
mean <- function(x) sum(x)

rm(T, c, mean)

```

4.  Enumerar los argumentos dentro de function y poner el c贸digo simplificado dentro de las llaves.

```{r de codigo repetido a funcion, escribir funcion}

#Varias opciones

expplot <- function (var) {
  miformato <-
    list(scale_color_manual(values = c("turquoise", "goldenrod1")),
         theme_light())
  p <- ggplot(penguins, aes(x = species, y = pull(penguins, var), color = sex)) +
    ylab(var) +
    miformato
  if (is.numeric(pull(penguins, var))) {
    p +
      geom_point(position = position_jitterdodge(), alpha = 0.3) +
      geom_boxplot(alpha = 0.5)
    
  } else {
    p +
      geom_jitter()
    
  }
}

```

 Utiliza comentarios (#) para explicar el razonamiento detr谩s de tus funciones. Se debe evitar explicar qu茅 se est谩 haciendo o c贸mo, ya que el propio c贸digo ya lo comunica. Tambi茅n se recomienda usar \# para separar apartados (Cmd/Ctrl + Shift + R).

5.  Probar con inputs diferentes

```{r de codigo repetido a funcion, pruebas}

expplot(var = "island") 
expplot(var = "year") 
expplot(var = "body_mass_g") 

 
```

Puedes querer convertir estas pruebas en test formales. En funciones complejas sirven para que, aunque hagas cambios, se pueda comprobar que la funcionalidad no se ha roto. Si est谩s interesado puede leer sobre tests aqui: <https://r-pkgs.org/testing-basics.html>

#### Ejercicio

驴C贸mo generalizar铆as la funci贸n expplot para que te sirviera para cualquier base de datos y cualquier variable categ贸rica?

#### Ejercicio

Genera una funci贸n para escalar (es decir, restar la media y dividir por la desviaci贸n t铆pica) las variables num茅ricas de penguins.

#### Argumentos

En general hay dos grupos: los que especifican los datos y los que especifican detalles de la ejecuci贸n de la funci贸n. Normalmente los que especifican datos van primero y los de detalle despu茅s y suelen tener valores por defecto (los m谩s comunes), para cuando no se especifique nada.

<!--# Ver ayuda de quantile -->

 Los nombres de los argumentos deben ser cortos y descriptivos. Hay algunos comunes pero poco descriptivos que tambi茅n se suelen usar (p.e. x, w, df, n, p, etc.), adem谩s de otros que ya existen y que no conviene definir de nuevo (p.e. na.rm).

Los argumentos se pueden especificar utilizando el nombre completo, una abreviatura unequ铆voca o el 贸rden de posici贸n (*unnamed arguments*), siendo este el 贸rden de prioridad a la hora de corresponder los argumentos con lo que se escribe.

 Generalmente s贸lo se usa el orden de posici贸n para para los primeros uno o dos argumentos, los m谩s comunes que todo el mundo conoce. Si se cambia un argumento de detalle con valor por defecto conviene poner siempre el combre completo.

 Usar espacios antes y despu茅s de "=" y despu茅s de "," hace mucho m谩s f谩cil identificar los componentes de la funci贸n.

```{r}

average <- mean(feet / 12 + inches, na.rm = TRUE)

average<-mean(feet/12+inches,na.rm=TRUE)

```

Hay un argumento especial llamado "...", que captura cualquier otro argumento que no se corresponde con los nombrados en la funci贸n. Se utiliza para transmitir argumentos a otras funciones incluidas en nuestra funci贸n.

```{r}

?plot

plot(1:5, 1:5)

plot(1:5, 1:5, main = "Estoy usando argumentos de par")

```

 Usar "..." hace que las funciones sean muy flexibles, pero hace necesario leer cuidadosamente la documentaci贸n para poder usarlo. Adem谩s, si se escribe mal un argumento no sale error.

```{r}

sum(1, 2, 5, na.mr = TRUE)
sum(1, 2, NA, na.mr = TRUE)

```

#### Valores de retorno

La 煤ltima expresi贸n ejecutada en una funci贸n es el valor de retorno. Es el resultado de ejecutar la funci贸n, a no ser que se especifique `invisible()`. Las funciones arrojan un s贸lo objeto. Si se quieren obtener m谩s, tendr谩 que ser en formato de lista.

<!--# Se os ocurre alg煤n caso donde usar invisible? -->

 La funci贸n `return()` se usa para indicar explicitamente qu茅 se quiere obtener en una funci贸n. Se recomienda su uso cuando el retorno no se espera al final de la funci贸n. P.e. en las ramas de una estructura if/else sobre todo hay alguna rama larga y compleja.

### *Lexical scoping* (mbito l茅xico)

Viene de *lexing*, el proceso de convertir una secuencia de caracteres (como en un script o p谩gina web) en una secuencia de tokens l茅xicos (cadenas con un significado asignado y por lo tanto identificado). Hay 4 principios b谩sicos en el 谩mbito l茅xico de R:

-   Name masking: si un nombre no est谩 definido en una funci贸n, R buscar谩 en un nivel superior. Las funciones conservan su environment y por tanto los valores definidos en su interior.

-   Functions vs. variables: encontrar funciones funciona igual que encontrar variables, excepto que si es obvio que est谩s buscando una funci贸n (p.e. `f(3)`), R ignorar谩 los objetos.

-   A fresh start: cada vez que se llama una funci贸n, se crea un nuevo environment para albergar la ejecuci贸n. Cada invocaci贸n es completamente independiente.

-   Dynamic lookup: el 谩mbito l茅xico indica donde y c贸mo buscar valores pero no *cu谩ndo*. R busca valores cuando se ejecuta la funci贸n, no cuando es creada, por lo que puede arrojar valores diferentes seg煤n lo que haya en el environment de ejecuci贸n.

Ejercicio 1: funci贸n b谩sica

Datos titanic

Ejercicio 2: funci贸n m谩s compleja para usar

## Informaci贸n principal

-   R for data Science (functions): <https://r4ds.had.co.nz/functions.html>

-   Advanced R (functions): <https://adv-r.hadley.nz/functions.html>

-   R for data Science (iteration): <https://r4ds.had.co.nz/iteration.html>

-   Advanced R (functionals): <https://adv-r.hadley.nz/functionals.html>

-   purrr 1.0.0: <https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/>

-   Learn to purrr (Rebecca Barter): <https://www.rebeccabarter.com/blog/2019-08-19_purrr>

-   Sacando el m谩ximo partido a Tidyverse: <https://github.com/Julenasti/intro_tidyverse/blob/main/04-scripts/intro_tidyverse.md>

-   R for Data Science (2e): <https://r4ds.hadley.nz/>

## No directamente relacionado pero 煤til

-   Style guide: <http://adv-r.had.co.nz/Style.html>

-   Quince consejos para mejorar nuestro c贸digo y flujo de trabajo con R: <https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129>
