---
title: "Iteraciones"
author: Julen Astigarraga y Ver칩nica Cruz-Alonso
date: 10/16/2023
toc: true
format:
  html: default
    # css: styles.css
  gfm: default
editor: visual
---

```{r instalar_paquetes}

# install.packages("tidyverse")
# install.packages("palmerpenguins")
library(tidyverse)
library(palmerpenguins)

```

<!--# Jul Me ha pedido instalar tambi칠n git2r ? -->

## Programaci칩n imperativa

Los bucles for y bucles while (for loops y while loops) son recomendables para adentrarse en el mundo de las iteraciones porque hacen que cada iteraci칩n sea muy expl칤cita por lo que est치 claro lo que est치 ocurriendo.

```{r for}

df_ej <- data.frame(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5)
)

salida <- vector("double", ncol(df_ej)) # 1. salida
for (i in seq_along(df_ej)) {           # 2. secuencia
  salida[[i]] <- max(df_ej[[i]])        # 3. cuerpo
}
salida

```

1.  Salida: aqu칤 determinamos el espacio de la salida. Esto es muy importante para la eficiencia puesto que si aumentamos el tama침o del for loop en cada iteraci칩n con `c()`, el bucle for ser치 mucho m치s lento. <!--# Jul Creo que no se entiende por qu칠 c() es peor. Poner ejemplo? -->

2.  Secuencia: aqu칤 determinamos sobre lo que queremos iterar. Cada ejecuci칩n del bucle for asignar치 i a un valor diferente de `seq_along(df)`. Si generamos un vector de longitud cero accidentalmente, si utilizamos `1:length(x)`, podemos obtener un error. <!--# Jul Se puede quitar este ejemplo, creo que se entiende sin el -->

```{r seq_along}

x <- vector("double", 0)
seq_along(x)
1:length(x)

```

3.  Cuerpo: aqu칤 determinamos lo que queremos que haga cada iteraci칩n. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existen distintas [variaciones de los bucles for](https://r4ds.had.co.nz/iteration.html#for-loop-variations): (i) modificar un objeto existente; (ii) bucles sobre nombres o valores; (iii) bucles cuando desconocemos la longitud de la salida; (iv) bucles cuando desconocemos la longitud de la secuencia de entrada, bucles while.

Algunos [errores comunes](https://adv-r.hadley.nz/control-flow.html) cuando se utilizan bucles for (ver 5.3.1 Common pitfalls).

Sin embargo, en R los bucles for no son tan importantes como pueden ser en otros lenguajes porque R es un lenguaje de programaci칩n funcional. Esto significa que *es posible envolver los bucles for en una funci칩n* y llamar a esa funci칩n en vez de utilizar el bucle.

Existe la creencia de que los bucles for son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles*. Cada funcional est치 dise침ado para una tarea espec칤fica, por lo que en cuanto lo ves en el c칩digo, inmediatamente sabes por qu칠 se est치 utilizando. Es decir, la principal ventaja es su claridad al hacer que el c칩digo sea m치s f치cil de escribir y de leer (ver este ejemplo avanzado para entenderlo: <https://adv-r.hadley.nz/functionals.html>, 9.3 Purrr style).

De todas formas, nunca os sint치is mal por utilizar un bucle en vez de un funcional. Los funcionales necesitan un paso m치s de abstracci칩n y pueden requerir tiempo hasta que los comprendamos. Lo m치s importante es que soluciones el problema y poco a poco ir escribiendo c칩digo cada vez m치s sencillo y elegante.

> Para ser significativamente m치s fiable, el c칩digo debe ser m치s transparente. En particular, las condiciones anidadas y los bucles deben considerarse con gran recelo. Los flujos de control complicados confunden a los programadores. El c칩digo desordenado suele ocultar errores.
>
> --- Bjarne Stroustrup ([Advanced R](https://adv-r.hadley.nz/index.html))

![](forloops.png)

!["Illustrations from Hadley Wickham's talk The Joy of Functional Programming (for Data Science)"](map_frosting.png)

<!--# Jul poner en espa침ol la fuente y luego un pie de foto con lo que representa -->

## Programaci칩n funcional

<!--# Explicar en una frase a que nos referimos con PF? Luego explicar칤a lo que es un funcional y luego como se trabaja, que es la frase que empieza por "primero" -->

Primero, solucionamos el problema para un elemento. Despu칠s, generamos una funci칩n que nos permita envolver la soluci칩n en una funci칩n. Por 칰ltimo, *aplicamos la funci칩n a todos los elementos que estamos interesados.*

Un funcional es una funci칩n que toma una funci칩n como entrada y devuelve un vector como salida.

```{r ejemplo_funcional}

aleatorizacion <- function(f) {
  f(rnorm(5))
}
aleatorizacion(median)

```

La ventaja de utilizar purrr en vez de bucles for es que nos permiten dividir los desaf칤os comunes de manipulaci칩n de listas (que pueden contener diferentes tipos de objetos) en partes independientes, por lo que cada bucle for tiene su propia funci칩n. La familia apply de R base soluciona problemas similares, pero purrr es m치s consistente y, por lo tanto, m치s f치cil de aprender. Una vez que dominemos la programaci칩n funcional, podremos solventar muchos problemas de iteraci칩n con menos c칩digo, m치s facilidad y menos errores.

Iteracionar sobre un vector es tan com칰n que el paquete {purrr} proporciona una familia de funciones (la familia map) para ello. Recordad que los data frames son listas de vectores de la misma longitud por lo que cualquier c치lculo por filas o columnas supone iteracionar sobre un vector. Existe una funci칩n en {purrr} para cada tipo de output/resultado. Los sufijos indican el tipo de output que queremos:

-   `map()` genera una lista.
-   `map_lgl()` genera un vector l칩gico.
-   `map_int()` genera un vector de n칰meros enteros.
-   `map_dbl()` genera un vector de n칰meros decimales.
-   `map_chr()` genera un vector de caracteres.
-   `map_vec()` genera un tipo arbitrario de vector, como fechas y factores.

游눠쯑Por qu칠 est치 funci칩n se llama *map*](https://adv-r.hadley.nz/functionals.html#map)?

```{r map_foco}

map_dbl(df_ej, mean)
df_ej |> 
  map_dbl(mean)

```

Comparando con un bucle el foco est치 en la operaci칩n que se est치 ejecutando (`mean()`), y no en el c칩digo necesario para iterar sobre cada elemento y guardar la salida.

## Iteraciones sobre un argumento

`map_*()` est치 vectorizado sobre un argumento, e.g. `(x)`<!--# Creo que no se entiende que es estar vectorizado -->

### Nuestro primer funcional: generando listas, `map()`

Toma un vector y una funci칩n, llama a la funci칩n una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {
  x ^ 2
}

map(1:4, cuadratica)

lapply(X = 1:4, FUN = cuadratica)

# algun uso mas interesante
glimpse(penguins)

#Jul me parece un poco lioso de entender el paso de hacer algo con cada elemento de un vector (figura de abajo) a hacer algo con cada columna de un data frame porque cada columna es un vector a su vez

# atajo de para generar una funcion anonima
map(penguins, \(x) length(unique(x)))

# salida dataframe
map_df(penguins, \(x) length(unique(x)))

```

![](images/map.png)

#### Ejercicio

Generad un vector, una funci칩n y aplicarle la funci칩n a cada uno de los elementos del vector utilizando `map()`. <!--# Intento enlazarlo con mis ejercicios para que la funci칩nya la tengan -->

#### Implementaci칩n de map()

```{r map_implementacion}

imple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

imple_map(1:4, cuadratica)

```

La funci칩n de {purrr} est치 escrita en C para maximizar el rendimiento, conserva los nombres y admite algunos atajos (e.g. `\(x)`).

### Nuestro segundo funcional: generando vectores, `map_*()`

#### Ejercicio

Dedicadle un par de minutos a entender lo que hacen las siguientes funciones:

```{r map_vectores}

map_lgl(penguins, is.numeric)
penguins_num <- penguins[ , map_lgl(penguins, is.numeric)]
map_dbl(penguins_num, median, na.rm = T)
map_chr(penguins, class)
map_int(penguins, \(x) length(unique(x)))
1:4 |> 
  map_vec(\(x) as.Date(ISOdate(x + 2023, 10, 16)))

```

Los argumentos que var칤an para cada ejecuci칩n vienen antes de la funci칩n y los argumentos que son los mismos para cada ejecuci칩n vienen despu칠s (`na.rm = T`).

![](images/map+fix.png)

R base tiene dos funciones de la familia `apply()` que pueden devolver vectores at칩micos: `sapply()` y `vapply()`. Recomendamos evitar `sapply()` porque intenta simplificar el resultado y elige un formato de salida por defecto, pudiendo devolver una lista, un vector o una matriz. `vapply()` es m치s seguro porque permite indicar el formato de salida con FUN.VALUE. La principal desventaja de `vapply()` es que se necesitan especificar m치s argumentos que en `map_*()`.

```{r vapply}

vapply(penguins_num, median, na.rm = T, FUN.VALUE = double(1))

```

```{r map_ejemplo_avanzado}

map(penguins, \(x) class(x))

glimpse(penguins)

# quitamos na's
penguins <- penguins |> 
  drop_na()

penguins_nested <- penguins |>
  group_by(species) |>
  nest() |> 
  mutate(
    lm_obj = map(data, \(dat) lm(
      bill_length_mm ~ body_mass_g,
      data = dat))
  )

# seleccionar cada elemento de la lista
penguins_nested[["lm_obj"]]

penguins_nested |>
  pluck("lm_obj")

# across para iteracionar sobre columnas
penguins_scaled <- penguins |>
  mutate(across(where(is.numeric), scale))



# Jul next lo explicaria como caso cuando no quieres iterar por columnas sino por grupos

#Jul no s칠 si dejar칤a el across para m치s adelante y que queden claras sus diferencias con hacer map y un select previo. Across es un doble map no? a cada columna le aplicamos un scale (map normal -iteracion por columnas), pero este scale cambia cada valor del vector (segundo map -iteracion por elemento del vector)

```

## Iteraciones sobre m칰ltiples argumentos

### Nuestro tercer funcional: dos entradas, `map2()`

`map2()` est치 vectorizado sobre dos argumentos, e.g. `(x, y)`

```{r map2_ejemplo}

potencia <- function(base, exponente) {
  base ^ exponente
}

x <- map(1:4, \(x) sample(5))
y <- map(1:4, \(x) sample(5))

map2(x, y, potencia)

```

丘뫅멜mportante! La primera iteraci칩n corresponde al primer valor del vector `x` y al primer valor del vector `y`. La segunda iteraci칩n corresponde al segundo valor del vector `x` y al segundo valor del vector `y`. No se hacen todas las combinaciones posibles entre ambos vectores.

![](images/map2.png)

```{r map2_implementacion}

imple_map2 <- function(x, y, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], y[[i]], ...)
  }
  out
}

imple_map2(x, y, potencia)

```

```{r map2_ejemplo_avanzado}

penguins_nested <- penguins |>
  group_by(species) |>
  nest() |> 
  mutate(
    lm_obj = map(data, \(dat) lm(
      bill_length_mm ~ body_mass_g,
      data = dat)),
    pred = map2(lm_obj, data,
                \(x, y) predict(x, y))
  )

# unnest()
penguins_nested |> 
  unnest(pred) |> 
  select(!c(data, lm_obj))

```

#### Ejercicio

Calculad la correlaci칩n entre las predicciones y `bill_length_mm`. Pista: hay que utilizar `map2_dbl()`

### Nuestro cuarto funcional: m칰ltiples entradas, `pmap()`

Toma una lista con cualquier n칰mero de argumentos de entrada.

```{r pmap_ejemplo}

# son analogos
map2(x, y, potencia)
pmap(list(x, y), potencia)

z <- map(1:4, \(x) sample(5))

pmap(list(x, y, z), rnorm)
# si no nombramos los elementos de la lista, pmap() usara los elementos de la lista en su orden para los argumentos consecutivos de la funci칩n
args3 <- list(mean = x, sd = y, n = z)
args3 |> 
  pmap(rnorm)

```

![](images/pmap.png)

## Sin resultado

### Nuestro quinto funcional: `walk()`, `walk2()` y `pwalk()`

Cuando queremos utilizar funciones por sus efectos secundarios/side effects (e.g. `ggsave()`) y no por su valor resultante. Lo importante es la acci칩n y no el valor u objeto resultante en R.

#### Ejercicio

En base a lo que dice en la definici칩n sobre la familia `walk()`, corred este c칩digo y entended lo que hace.

```{r walk_ejemplo}

penguins_nested <- penguins_nested |> 
  mutate(path = str_glue("penguins_{species}.csv"))

penguins_nested

walk2(penguins_nested$data, penguins_nested$path, write_csv)

```

DIBUJO VERO <!--# Este dibujo no se si me convence. Esque creo que no aporta mucho porque lo suyo ser칤a dibujar la acci칩n que es el resultado y no se me ocurre -->

游눠Ejemplos de algunas tareas espec칤ficas con {purrr}: <https://r4ds.hadley.nz/iteration>

## Otras posibles iteraciones

### Operadores funcionales <!--# Jul Haria una apartado para esto fuera de "otras posibles iteraciones" porque no son iteraciones si no modificadores. Me gusta -->

Cuando utilizamos las funciones `map()` para repetir muchas operaciones, aumenta la probabilidad de que una de esas operaciones falle y no obtenamos ning칰n resultado. {purrr\] proporciona algunos operadores funcionales (function operators) en forma de adverbios para asegurar que un error no arruine todo el proceso: `safely()`, `possibly()`, `quietly()`. Para m치s informaci칩n ver: <https://r4ds.had.co.nz/iteration.html>, 21.6 Dealing with failure.

```{r ejemplo_operador_funcional}
#| error: true

x <- list(10, "b", 3)

x |> 
  map(log)

x |> 
  map(safely(log))

x |> 
  map(safely(log)) |> 
  transpose()

x |> 
  map(possibly(log, NA_real_))

```

### Funcionales predicate <!--# Jul Creo que esto lo juntar칤a con across porque me parece la misma filosofia: selecciono unas columnas y hago cosas jaja-->

Los predicados son funciones que devuelven un solo TRUE o FALSE (e.g., `is.character()`). As칤, un predicado funcional aplica un predicado a cada elemento de un vector: `keep()`, `discard()`, `some()`, `every()`, `detect()`, `detect_index()`... Para m치s informaci칩n ver: <https://r4ds.had.co.nz/iteration.html>, 21.9.1 Predicate functions.

```{r ejemplo_predicado_funcional}

penguins |> 
  keep(is.numeric)

penguins |> 
  discard(is.numeric)

penguins |> 
  every(is.numeric)

```

### Reduce y Accumulate

`reduce()` es una forma 칰til de generalizar una funci칩n que funciona con dos entradas (funci칩n binaria) para trabajar con cualquier n칰mero de entradas.

`accumulate()` en lugar de devolver solo el resultado final, devuelve todos los resultados intermedios.

<!--# Jul Esto ser칤a para aplicar iterativamente en cascada no? Quiz치s lo juntar칤a con nest porque es como otra forma de iterar (por grupos o en cascada). Creo que quitar칤a accumulate porque es solo una casuistica de reduce. Me gusta mucho el dibujo que viene en el libro para reduce para entenderlo-->

```{r ejemplo_reduce}

ls <- list(
  age = tibble(name = c("Vero", "Julen"), age = c(100, 140)),
  sex = tibble(name = c("Vero", "Julen"), sex = c("F", "M")),
  height = tibble(name = c("Vero", "Julen"), height = c("180", "150"))
)

ls |> 
  reduce(full_join, by = "name")

```

Este taller est치 principalmente basado en la primera edici칩n del libro [R for Data Science](https://r4ds.had.co.nz/) de Hadley Wickham & Garrett Grolemund y la segunda edici칩n del libro [Advanced R](https://adv-r.hadley.nz/index.html) de Hadley Wickham.

## M치s informaci칩n

-   R for data Science (functions): <https://r4ds.had.co.nz/functions.html>

-   Advanced R (functions): <https://adv-r.hadley.nz/functions.html>

-   R for data Science (iteration): <https://r4ds.had.co.nz/iteration.html>

-   Advanced R (functionals): <https://adv-r.hadley.nz/functionals.html>

-   purrr 1.0.0: <https://www.tidyverse.org/blog/2022/12/purrr-1-0-0/>

-   Learn to purrr (Rebecca Barter): <https://www.rebeccabarter.com/blog/2019-08-19_purrr>

-   Sacando el m치ximo partido a Tidyverse: <https://github.com/Julenasti/intro_tidyverse/blob/main/04-scripts/intro_tidyverse.md>

-   R for Data Science (2e): <https://r4ds.hadley.nz/>

### No directamente relacionado pero 칰til

-   Style guide: <http://adv-r.had.co.nz/Style.html>

-   Quince consejos para mejorar nuestro c칩digo y flujo de trabajo con R: <https://www.revistaecosistemas.net/index.php/ecosistemas/article/view/2129>

------------------------------------------------------------------------

<details>

<summary>Session Info</summary>

```{r session-info}
Sys.time()
git2r::repository()
sessionInfo()
```

</details>
