---
title: "Iteraciones"
format: html
editor: visual
---

<!-- lo que está hasta programación imperativa puede encajar mejor en la intro del taller, creo -->

La idea de pasar una función a otra función es una idea muy potente y es una de las características que hace que R sea un lenguaje de programación funcional. Además de las funciones, otra herramienta para reducir la duplicación son las iteraciones que sirven para realizar la misma acción a múltiples entradas. Existen dos grandes paradigmas de iteración: la programación imperativa y la programación funcional. En este taller, nos centraremos principalmente en la **programación funcional** y aprenderemos a utilizar el paquete {purrr}, que proporciona funciones para eliminar muchos bucles comunes.

## Programación imperativa

Los bucles for y bucles while (for loops y while loops) son recomendables para adentrarse en el mundo de las iteraciones porque hacen que cada iteración sea muy explícita por lo que está claro lo que está ocurriendo.

```{r for}

df_ej <- data.frame(
  a = rnorm(5),
  b = rnorm(5),
  c = rnorm(5)
)

salida <- vector("double", ncol(df_ej)) # 1. output
for (i in seq_along(df_ej)) {           # 2. sequence
  salida[[i]] <- max(df_ej[[i]])        # 3. body
}
salida

```

1.  Salida: aquí determinamos el espacio de la salida. Esto es muy importante para la eficiencia puesto que si aumentamos el tamaño del for loop en cada iteración con `c()`, el bucle for será mucho más lento.

2.  Secuencia: aquí determinamos sobre lo que queremos iterar. Cada ejecución del bucle for asignará i a un valor diferente de `seq_along(df)`. Si generamos un vector de longitud cero accidentalmente, si utilizamos `1:length(x)`, podemos obtener un error.

```{r seq_along}

x <- vector("double", 0)
seq_along(x)
1:length(x)

```

3.  Cuerpo: aquí determinamos lo que queremos que haga cada iteración. Se ejecuta repetidamente, cada vez con un valor diferente para `i`.

Existen distintas [variaciones de los bucles for](https://r4ds.had.co.nz/iteration.html#for-loop-variations): (i) modificar un objeto existente; (ii) bucles sobre nombres o valores; (iii) bucles cuando desconocemos la longitud de la salida; (iv) bucles cuando desconocemos la longitud de la secuencia de entrada, bucles while.

Algunos [errores comunes](https://adv-r.hadley.nz/control-flow.html) cuando se utilizan bucles for (ver 5.3.1 Common pitfalls).

<!-- lo que está en cursiva es lo que quería resaltar porque lo veremos a continuación -->

Sin embargo, en R los bucles for no son tan importantes como pueden ser en otros lenguajes porque R es un lenguaje de programación funcional. Esto significa que *es posible envolver los bucles for en una función* y llamar a esa función en vez de utilizar el bucle.

Existe la creencia de que los bucles for son lentos, pero la desventaja real de *los bucles for es que son demasiado flexibles*. Cada funcional está diseñado para una tarea específica, por lo que cuando reconoces el funcional, inmediatamente sabes por qué se está utilizando. Es decir, la principal ventaja es su claridad al hacer que el código sea más fácil de escribir y de leer.

De todas formas, nunca os sintáis mal por utilizar un bucle en vez de un funcional. Los funcionales necesitan un paso más de abstracción y pueden requerir tiempo hasta que los comprendamos. Lo más importante es que soluciones el problema y poco a poco ir escribiendo código cada vez más sencillo y elegante.

> Para ser significativamente más fiable, el código debe ser más transparente. En particular, las condiciones anidadas y los bucles deben considerarse con gran recelo. Los flujos de control complicados confunden a los programadores. El código desordenado suele ocultar errores.
>
> --- Bjarne Stroustrup ([Advanced R](https://adv-r.hadley.nz/index.html))

## Programación funcional

Primero, solucionamos el problema para un elemento. Después, generamos una función que nos permita envolver la solución en una función. Por último, *aplicamos la función a todos los elementos que estamos interesados.*

Un funcional es una función que toma una función como entrada y devuelve un vector como salida.

```{r}

aleatorizacion <- function(f) {
  f(rnorm(5))
}
aleatorizacion(median)

```

El objetivo de utilizar purrr en vez de bucles for es que nos permiten dividir los desafíos comunes de manipulación de listas en partes independientes, por lo que cada bucle for tiene su propia función. La familia apply de R base soluciona problemas similares, pero purrr es más consistente y por lo tanto más fácil de aprender. Una vez que dominemos la programación funcional, podremos solventar muchos problemas de iteración con menos código, más facilidad y menos errores.

Iteracionar sobre un vector es tan común que el paquete {purrr} proporciona una familia de funciones para ello (recordad que los data frames son listas conteniendo vectores de la misma longitud). Existe una función para cada tipo de output/resultado. Los sufijos indican el tipo de output que queremos:

-   `map()` genera una lista
-   `map_lgl()` genera un vector lógico
-   `map_int()` genera un vector de números enteros
-   `map_dbl()` genera un vector de números decimales
-   `map_chr()` genera un vector de caracteres
-   `map_vec()` genera un tipo arbitrario de vector, como fechas y factores

¿[Por qué está función se llama *map*](https://adv-r.hadley.nz/functionals.html#map)?

```{r}

library(tidyverse)

map_dbl(df_ej, mean)
df_ej |> 
  map_dbl(mean)

```

Comparando con un bucle el foco está en la operación que se está ejecutando (`mean()`), y no en el código necesario para iterar sobre cada elemento y guardar la salida.

## Iteraciones sobre un argumento

`map_*()` está vectorizado sobre un argumento, e.g. `(x)`

### Nuestro primer funcional: generando listas, map()

Toma un vector y una función, llama a la función una vez por cada elemento del vector y devuelve los resultados en una lista. `map(1:3, f)` es equivalente a `list(f(1), f(2), f(3))`. Es el equivalente de `lapply()` de R base.

```{r map_ejemplo}

cuadratica <- function(x) {
  x ^ 2
}

map(1:4, cuadratica)

lapply(X = 1:4, FUN = cuadratica)

```

DIBUJO VERO 1

Implementación de map()

```{r map_implementacion}

imple_map <- function(x, f, ...) {
  out <- vector("list", length(x))
  for (i in seq_along(x)) {
    out[[i]] <- f(x[[i]], ...)
  }
  out
}

imple_map(1:4, cuadratica)

```

### Nuestro segundo funcional: generando vectores, `map_*()`

```{r map_vectores}
titanic <- as_tibble(Titanic)

map_lgl(titanic, is.numeric)
map_int(titanic, \(x) length(unique(x)))
map_dbl(titanic, median)
map_chr(titanic, class)
1:3 |> 
  map_vec(\(x) as.Date(ISOdate(x + 2022, 10, 5)))

```

R base tiene dos funciones `apply()` que pueden devolver vectores atómicos: `sapply()` y `vapply()`. Recomendamos evitar `sapply()` porque intenta simplificar el resultado, por lo que puede devolver una lista, un vector o una matriz. `vapply()` es más seguro porque permite proporcionar una plantilla, FUN.VALUE, que describe la forma de salida. La principal desventaja de `vapply()` es que se necesitan especificar más argumentos que en `map_*()`.

```{r vapply}

vapply(titanic, median, FUN.VALUE = double(1))

```

## Iteraciones sobre múltiples argumentos

A veces necesitamos iteracionar sobre diversos inputs/entradas en paralelo

### Nuestro tercer funcional: dos inputs, map2()

map2() está vectorizado sobre dos argumentos

Ejemplo, dibujo 2, comparación con for

### Nuestro cuarto funcional: múltiples inputs, pmap()

Toma una lista con cualquier número de argumentos

Ejemplo, dibujo 3

## Sin output/resultado

### Nuestro quinto funcional: walk(), walk2() y pwalk()

Cuando queremos utilizar funciones por sus side effects (e.g. ggsave()) y no por su resultado. Los outputs son efímeros y el input es devuelto de forma invisible.

Dibujo 4, comparación con R base

Examples of some specific tasks with purrr: https://r4ds.hadley.nz/iteration

## Lidiando con el fracaso, 329

Cuando utilizamos las funciones map() para repetir muchas operaciones, las posibilidades de que una de esas operaciones falle son mucho mayores. Cuando esto suceda, recibimos un mensaje de error y no obtenemos los resultados. purrr proporciona algunos operadores de funciones (function operators) en forma de adverbios para asegurar que una manzana podrida no arruine todo el barril.

safely(), possibly(), quietly() algún ejemplo + link para más información

## Otros patrones de bucles for, 336

### Funcionales predicate

Los predicate son funciones que devuelven un solo TRUE o FALSE (e.g., is.character())

Un predicado funcional aplica un predicado a cada elemento de un vector

keep(), discard(), some(), every(), detect(), detect_index() algún ejemplo + link para más información

### Reduce and Accumulate

reduce(): es una forma útil de generalizar una función que funciona con dos entradas (función binaria) para trabajar con cualquier número de entradas

accumulate(): en lugar de devolver solo el resultado final, devuelve todos los resultados intermedios

un ejemplo de cada

Ejemplo final avanzado comparando purrr, lapply y for (ver purrr style, pag 221 Advanced R)

DIBUJOS ALLISON PURRR FOR
